CCS PCM C Compiler, Version 4.104, 5967               13-Oct-15 15:26

               Filename: D:\tai lieu viettel\dk qua dt\code3\code25-9\code3\main.lst

               ROM used: 4361 words (53%)
                         Largest free fragment is 2048
               RAM used: 176 (48%) at main() level
                         272 (74%) worst case
               Stack:    5 worst case (4 in main + 1 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   032
001D:  BTFSS  0B.5
001E:  GOTO   021
001F:  BTFSC  0B.2
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   241
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   22E
.................... #include "main.h" 
.................... #include <16F887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM,adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
....................  
.................... #use delay(clock=20000000) 
*
02C2:  MOVLW  6C
02C3:  MOVWF  04
02C4:  BSF    03.7
02C5:  MOVF   00,W
02C6:  BTFSC  03.2
02C7:  GOTO   2D5
02C8:  MOVLW  06
02C9:  MOVWF  78
02CA:  CLRF   77
02CB:  DECFSZ 77,F
02CC:  GOTO   2CB
02CD:  DECFSZ 78,F
02CE:  GOTO   2CA
02CF:  MOVLW  7B
02D0:  MOVWF  77
02D1:  DECFSZ 77,F
02D2:  GOTO   2D1
02D3:  DECFSZ 00,F
02D4:  GOTO   2C8
02D5:  RETURN
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... #byte portb=0x06 
.................... #byte portc=0x07 
.................... #byte porte=0x09 
.................... #byte trisc=0x87 
.................... #byte trise=0x89 
.................... #byte pie1=0x8C 
.................... #bit C1=portc.1 
.................... #bit C2=portc.2 
.................... #bit C3=portc.3 
.................... #bit B0=portb.0 
.................... #bit B1=portb.1 
.................... #bit B2=portb.2 
.................... #bit B3=portb.3 
.................... #bit B4=portb.4 
.................... #bit B5=portb.5 
.................... #bit B6=portb.6 
.................... #bit B7=portb.7 
.................... #bit trisc1=trisc.1 
.................... #bit trisc2=trisc.2 
.................... #bit trisc3=trisc.3 
.................... #bit Led1=portb.2 
.................... #bit Led2=portb.3 
.................... #bit trise1=trise.1 
.................... #bit rcie=pie1.5 
.................... //!p_char1=sizeof(clcc)/sizeof(char); 
.................... //!p_char2=sizeof(on1)/sizeof(char); 
.................... //!    lcd_putc('\f'); 
.................... //!    for(i=1;i<=p_char1;i++){      
.................... //!     lcd_gotoxy(i,1); 
.................... //!     lcd_putc("i");} 
.................... //!     for(i=1;i<=p_char2;i++){   
.................... //!     lcd_gotoxy(i,2); 
.................... //!     lcd_putc("i"); 
.................... //!    } 
.................... //!    RxInit(); 
.................... //!    smsinit(); 
.................... //!    if(IsStringReceived(on1)){ 
.................... //!    lcd_putc('\f'); 
.................... //!    for(i=1;i<=16;i++){      
.................... //!     lcd_gotoxy(i,1); 
.................... //!     lcd_putc(smstext[i-1]); 
.................... //!     lcd_gotoxy(i,2); 
.................... //!     lcd_putc(RxBuf[i-1]); 
.................... //!    } 
.................... //!    } 
.................... //!    delay_ms(2000); 
.................... //!    lcd_putc("\f"); 
.................... //!    lcd_gotoxy(1,1); 
.................... //!    if(gsmstr(smstext,on1)==1){ 
.................... //!    lcd_putc("True"); 
.................... //!    } 
.................... //!    IsStringReceived(on1); 
.................... //!    p_char1=sizeof(clcc)/sizeof(char); 
.................... //!p_char2=sizeof(on1)/sizeof(char); 
.................... //!if(gsmstr(RxBuf,on1)==1){ 
.................... //!lcd_putc('\f'); 
.................... //!    for(i=1;i<=p_char1;i++){      
.................... //!     lcd_gotoxy(i,1); 
.................... //!     lcd_putc("i");} 
.................... //!     for(i=1;i<=p_char2;i++){   
.................... //!     lcd_gotoxy(i,2); 
.................... //!     lcd_putc("i"); 
.................... //!    } 
.................... //!} 
.................... //!int gsmstr(char *str,char *str1){ 
.................... //!int t=0; 
.................... //!for(i=0;i<p_char1-p_char2;i++){ 
.................... //!   t=0; 
.................... //!   for(j=0;j<p_char2;j++){ 
.................... //!      if(str[i+j]==str1[j]) 
.................... //!      { 
.................... //!         t++; 
.................... //!      } 
.................... //!   } 
.................... //!   if(t==p_char2)return 1;    
.................... //!} 
.................... //!return 0; 
.................... //!} 
....................  
.................... #include "function.c" 
.................... #include "myLCD16x2.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
....................    LCD 16x2 Driver 
....................    Using I2C interface 
....................    Coding : Hoang Nguyen 
....................    Date : 25/3/2010 
....................    Rev : 1.0 
....................    Platform : PIC C Compiler 
.................... */ 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... #define LCD_EN_PIN PIN_D2 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D1 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
.................... //#define LCD_TRIS_LOCATION PORTD 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................  
.................... //EPIC 2 dung 4 bit thap 
.................... //EPIC1 dung 4 bit cao 
.................... //#define input_data() input_data_port()&0xf0 
.................... //#define input_data() ((input_data_port()&0x0f)<<4) 
.................... //#define output_data(n) output_data_port((n<<4)|(input_data_port()&0x0f)) 
.................... //#define output_data(n) output_data_port(n|(input_data_port()&0xf0)) 
....................  
.................... void output_data( BYTE n )  
.................... { 
....................   
....................        
....................       output_bit(PIN_D4,n&0x01); 
....................       output_bit(PIN_D5,(n>>1)&0x01); 
....................       output_bit(PIN_D6,(n>>2)&0x01); 
....................       output_bit(PIN_D7,(n>>3)&0x01) ; 
....................       //output_d(n<<4); 
....................        
.................... } 
....................  
.................... void lcd_strobe() { 
....................       output_high(LCD_EN_PIN); 
....................       delay_us(2); 
....................       output_low(LCD_EN_PIN); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       output_data(n); 
....................       delay_cycles(1); 
....................       output_high(LCD_EN_PIN); 
....................       delay_us(2); 
....................       output_low(LCD_EN_PIN); 
.................... } 
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       output_low(LCD_RS_PIN); 
....................       delay_ms(5);//while ( bit_test(lcd_read_byte(),7) ) ;//hay bi treo 
....................        
....................       output_bit(LCD_RS_PIN,address); 
....................       //delay_cycles(1); 
....................       output_low(LCD_RW_PIN); 
....................       //delay_cycles(1); 
....................       output_low(LCD_EN_PIN); 
....................       lcd_send_nibble(n >> 4); 
....................       lcd_send_nibble(n & 0xf); 
.................... } 
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     //set_tris_lcd(LCD_WRITE); 
....................     delay_ms(10); 
....................     output_low(LCD_RS_PIN); 
....................     delay_ms(10); 
....................     output_low(LCD_RW_PIN); 
....................     delay_ms(10); 
....................     output_low(LCD_EN_PIN); 
....................     delay_ms(10); 
....................     for(i=1;i<=3;++i) { 
....................        lcd_send_nibble(3); 
....................        delay_ms(5); 
....................     } 
....................     lcd_send_nibble(2); 
....................     for(i=0;i<=3;++i) 
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
.................... } 
....................  
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
....................      address=lcd_line_two; 
....................    else 
....................      address=0; 
....................    address+=x-1; 
....................    lcd_send_byte(0,0x80|address); 
.................... } 
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
....................      case '\f'   : lcd_send_byte(0,1); 
....................                    delay_ms(2); 
....................                                            break; 
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
....................      default     : lcd_send_byte(1,c);     break; 
....................    } 
.................... } 
....................  
.................... void lcd_putstring( char *c,char x,char y) { 
.................... int i; 
....................    lcd_gotoxy(x,y); 
....................    i=0; 
....................    while(c[i] != 0) 
....................    { 
....................       lcd_putc(c[i]); 
....................       i++; 
....................    } 
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0E58:  MOVF   1D,W
0E59:  MOVWF  21
0E5A:  MOVF   1C,W
0E5B:  MOVWF  20
0E5C:  MOVF   21,W
0E5D:  MOVWF  7A
0E5E:  MOVF   20,W
0E5F:  MOVWF  04
0E60:  BCF    03.7
0E61:  BTFSC  7A.0
0E62:  BSF    03.7
0E63:  MOVF   00,F
0E64:  BTFSC  03.2
0E65:  GOTO   66A
0E66:  INCF   20,F
0E67:  BTFSC  03.2
0E68:  INCF   21,F
0E69:  GOTO   65C
....................    while(*s2 != '\0') 
....................    { 
0E6A:  MOVF   1F,W
0E6B:  MOVWF  7A
0E6C:  MOVF   1E,W
0E6D:  MOVWF  04
0E6E:  BCF    03.7
0E6F:  BTFSC  7A.0
0E70:  BSF    03.7
0E71:  MOVF   00,F
0E72:  BTFSC  03.2
0E73:  GOTO   689
....................       *s = *s2; 
0E74:  MOVF   1E,W
0E75:  MOVWF  04
0E76:  BCF    03.7
0E77:  BTFSC  1F.0
0E78:  BSF    03.7
0E79:  MOVF   00,W
0E7A:  MOVWF  24
0E7B:  MOVF   20,W
0E7C:  MOVWF  04
0E7D:  BCF    03.7
0E7E:  BTFSC  21.0
0E7F:  BSF    03.7
0E80:  MOVF   24,W
0E81:  MOVWF  00
....................       ++s; 
0E82:  INCF   20,F
0E83:  BTFSC  03.2
0E84:  INCF   21,F
....................       ++s2; 
0E85:  INCF   1E,F
0E86:  BTFSC  03.2
0E87:  INCF   1F,F
....................    } 
0E88:  GOTO   66A
....................  
....................    *s = '\0'; 
0E89:  MOVF   20,W
0E8A:  MOVWF  04
0E8B:  BCF    03.7
0E8C:  BTFSC  21.0
0E8D:  BSF    03.7
0E8E:  CLRF   00
....................    return(s1); 
0E8F:  MOVF   1C,W
0E90:  MOVWF  78
0E91:  MOVF   1D,W
0E92:  MOVWF  79
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
*
0516:  BSF    03.6
0517:  MOVF   35,W
0518:  MOVWF  7A
0519:  MOVF   34,W
051A:  MOVWF  04
051B:  BCF    03.7
051C:  BTFSC  7A.0
051D:  BSF    03.7
051E:  MOVF   00,F
051F:  BTFSC  03.2
0520:  GOTO   561
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0521:  MOVF   35,W
0522:  MOVWF  39
0523:  MOVF   34,W
0524:  MOVWF  38
0525:  MOVF   37,W
0526:  MOVWF  3B
0527:  MOVF   36,W
0528:  MOVWF  3A
0529:  MOVF   3B,W
052A:  MOVWF  7A
052B:  MOVF   3A,W
052C:  MOVWF  04
052D:  BCF    03.7
052E:  BTFSC  7A.0
052F:  BSF    03.7
0530:  MOVF   00,F
0531:  BTFSC  03.2
0532:  GOTO   54E
0533:  MOVF   39,W
0534:  MOVWF  7A
0535:  MOVF   38,W
0536:  MOVWF  04
0537:  BCF    03.7
0538:  BTFSC  7A.0
0539:  BSF    03.7
053A:  MOVF   00,W
053B:  MOVWF  3C
053C:  MOVF   3B,W
053D:  MOVWF  7A
053E:  MOVF   3A,W
053F:  MOVWF  04
0540:  BCF    03.7
0541:  BTFSC  7A.0
0542:  BSF    03.7
0543:  MOVF   00,W
0544:  SUBWF  3C,W
0545:  BTFSS  03.2
0546:  GOTO   54E
0547:  INCF   38,F
0548:  BTFSC  03.2
0549:  INCF   39,F
054A:  INCF   3A,F
054B:  BTFSC  03.2
054C:  INCF   3B,F
054D:  GOTO   529
....................  
....................       if (*t == '\0') 
054E:  MOVF   3B,W
054F:  MOVWF  7A
0550:  MOVF   3A,W
0551:  MOVWF  04
0552:  BCF    03.7
0553:  BTFSC  7A.0
0554:  BSF    03.7
0555:  MOVF   00,F
0556:  BTFSS  03.2
0557:  GOTO   55D
....................          return s1; 
0558:  MOVF   34,W
0559:  MOVWF  78
055A:  MOVF   35,W
055B:  MOVWF  79
055C:  GOTO   564
....................       ++s1; 
055D:  INCF   34,F
055E:  BTFSC  03.2
055F:  INCF   35,F
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
0560:  GOTO   517
....................    return 0; 
0561:  MOVLW  00
0562:  MOVWF  78
0563:  MOVWF  79
.................... } 
0564:  BCF    03.6
0565:  RETURN
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1026:  BCF    03.6
1027:  CLRF   27
1028:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define RXBUFSIZE 55 
.................... #define smssize 26 
.................... #define numbersize 16 
....................  
.................... //char init[]="GSM initializing"; 
.................... int RxBuf[RXBUFSIZE]; 
.................... char numberphone[numbersize]; 
.................... char smstext[smssize]; 
.................... int RxHead = 0; 
.................... //char khesim; 
.................... int i,numsms=0; 
.................... int calling=0,startsms=0; 
.................... //const char cmti[]="+CMTI: \"SM\","; 
.................... const char error1[]="Khong thanh cong"; 
.................... const char OK[]="OK"; 
.................... const char cusd[]="+CUSD"; 
.................... const char setkttk[]="AT+CUSD=1"; 
.................... const char kttka[]="AT+CUSD=1,\"\*101\#\""; 
.................... const char kttkb[]="AT+CUSD=1,\"\*102\#\""; 
.................... const char saicuphap[]="Sai cu phap"; 
.................... const char msg9[]="DS:"; 
.................... const char kttk1[]="kttk1"; 
.................... const char kttk2[]="kttk2"; 
.................... const char dssdt[]="dssdt"; 
.................... const char cnmi[]="AT+CNMI=2,2,0,0,0"; 
.................... const char cmgd[]="AT+CMGD=1"; 
.................... const char cmgdall[]="AT+CMGD=1,2"; 
.................... //const char cpms[]="AT+CPMS=1"; 
.................... const char quenmk[]="quenmk"; 
.................... const char doimk[]="doimk"; 
.................... const char doiad[]="doiad"; 
.................... const char msg1[]="Danh sach nguoi dieu khien khong duoc qua 5 nguoi, xoa bot so dien thoai"; 
.................... const char msg2[]="Khong dung so dien thoai"; 
.................... const char msg3[]="Da them:"; 
.................... const char msg4[]="Da xoa: "; 
.................... const char msg5[]="Do dai mat khau la 6 ky tu"; 
.................... const char msg6[]="Sai mat khau"; 
.................... const char msg7[]="Doi mat khau thanh cong"; 
.................... const char msg8[]="Doi admin thanh cong"; 
.................... const char them[]="them0"; 
.................... const char xoahet[]="xoahet"; 
.................... const char xoa[]="xoa0"; 
.................... //const char cpas[]="+CPAS: 3"; 
.................... //const char atcpas[]="AT+CPAS"; 
.................... const char atclcc[]="AT+CLCC"; 
.................... const char clcc[]="+CLCC: 1,1,4,0,0"; 
.................... //const char new[]="+CMGR: \"REC UNREAD\""; 
.................... const char cmee[]="AT+CMEE=0"; 
.................... const char cmgf[]="AT+CMGF=1"; 
.................... //const char unread[]="AT+CMGL=\"REC UNREAD\""; 
.................... //const char cmgr[]="AT+CMGR=1"; 
.................... //char *atorder; 
.................... char numfull[6],numtem1[numbersize]; 
.................... char numtem[numbersize]; 
.................... char mk[7]; 
.................... int p_char1,p_char2; 
.................... int newsms=0; 
.................... int admin=0; 
.................... int smsmode,smscount; 
.................... char *c; 
.................... char *ret_val; 
.................... //ham tim vi tri 1 ky tu thu i trong chuoi 
.................... int gsmchr(char str[],int size,char ch, int num){ 
*
03FF:  BSF    03.6
0400:  CLRF   6A
.................... int t=0; 
.................... for(i=0;i<size;i++){ 
0401:  CLRF   71
0402:  MOVF   67,W
0403:  SUBWF  71,W
0404:  BTFSC  03.0
0405:  GOTO   419
.................... if(str[i]==ch)t++; 
0406:  MOVF   71,W
0407:  ADDWF  65,W
0408:  MOVWF  04
0409:  BCF    03.7
040A:  BTFSC  66.0
040B:  BSF    03.7
040C:  MOVF   68,W
040D:  SUBWF  00,W
040E:  BTFSC  03.2
040F:  INCF   6A,F
.................... if(t==num)return i; 
0410:  MOVF   69,W
0411:  SUBWF  6A,W
0412:  BTFSS  03.2
0413:  GOTO   417
0414:  MOVF   71,W
0415:  MOVWF  78
0416:  GOTO   41B
.................... } 
0417:  INCF   71,F
0418:  GOTO   402
.................... return 0; 
0419:  MOVLW  00
041A:  MOVWF  78
.................... } 
041B:  BCF    03.6
041C:  RETURN
.................... void eeprom_write_string(unsigned int8 addr,unsigned char*str) 
.................... { 
....................   while(*str) 
....................   { 
*
059E:  BSF    03.6
059F:  MOVF   67,W
05A0:  MOVWF  7A
05A1:  MOVF   66,W
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  BTFSC  7A.0
05A5:  BSF    03.7
05A6:  MOVF   00,F
05A7:  BTFSC  03.2
05A8:  GOTO   5D2
....................   write_eeprom(addr,*str); 
05A9:  MOVF   67,W
05AA:  MOVWF  7A
05AB:  MOVF   66,W
05AC:  MOVWF  04
05AD:  BCF    03.7
05AE:  BTFSC  7A.0
05AF:  BSF    03.7
05B0:  MOVF   00,W
05B1:  MOVWF  68
05B2:  MOVF   65,W
05B3:  MOVWF  0D
05B4:  MOVF   68,W
05B5:  MOVWF  0C
05B6:  BSF    03.5
05B7:  BCF    0C.7
05B8:  BSF    0C.2
05B9:  BCF    03.5
05BA:  BCF    03.6
05BB:  MOVF   0B,W
05BC:  MOVWF  77
05BD:  BCF    0B.7
05BE:  BSF    03.5
05BF:  BSF    03.6
05C0:  MOVLW  55
05C1:  MOVWF  0D
05C2:  MOVLW  AA
05C3:  MOVWF  0D
05C4:  BSF    0C.1
05C5:  BTFSC  0C.1
05C6:  GOTO   5C5
05C7:  BCF    0C.2
05C8:  MOVF   77,W
05C9:  BCF    03.5
05CA:  BCF    03.6
05CB:  IORWF  0B,F
....................   addr++; 
05CC:  BSF    03.6
05CD:  INCF   65,F
....................   str++; 
05CE:  INCF   66,F
05CF:  BTFSC  03.2
05D0:  INCF   67,F
....................   } 
05D1:  GOTO   59F
.................... } 
05D2:  BCF    03.6
05D3:  RETURN
.................... void eeprom_read_string(unsigned int8 addr, unsigned char* str,unsigned int8 len) 
.................... { 
....................   unsigned int8 i; 
....................   for(i=0;i<len;i++) 
*
041D:  BSF    03.6
041E:  CLRF   61
041F:  MOVF   60,W
0420:  SUBWF  61,W
0421:  BTFSC  03.0
0422:  GOTO   43D
....................   { 
....................       str[i]=0; 
0423:  MOVF   61,W
0424:  ADDWF  5E,W
0425:  MOVWF  04
0426:  BCF    03.7
0427:  BTFSC  5F.0
0428:  BSF    03.7
0429:  CLRF   00
....................       str[i]=read_eeprom(addr+i);       
042A:  MOVF   61,W
042B:  ADDWF  5E,W
042C:  MOVWF  04
042D:  BCF    03.7
042E:  BTFSC  5F.0
042F:  BSF    03.7
0430:  MOVF   61,W
0431:  ADDWF  5D,W
0432:  MOVWF  64
0433:  MOVF   64,W
0434:  MOVWF  0D
0435:  BSF    03.5
0436:  BCF    0C.7
0437:  BSF    0C.0
0438:  BCF    03.5
0439:  MOVF   0C,W
043A:  MOVWF  00
....................   } 
043B:  INCF   61,F
043C:  GOTO   41F
....................   str[len]=0; 
043D:  MOVF   60,W
043E:  ADDWF  5E,W
043F:  MOVWF  04
0440:  BCF    03.7
0441:  BTFSC  5F.0
0442:  BSF    03.7
0443:  CLRF   00
.................... } 
0444:  BCF    03.6
0445:  RETURN
.................... //ham xoa buffer va so dien thoai 
.................... void RxInit(){ 
....................  RxHead=0; 
*
0330:  CLRF   70
....................  //for(i=0;i<RXBUFSIZE;i++) 
....................    RxBuf[0]=0; 
0331:  CLRF   29
....................  for(i=0;i<numbersize;i++) 
0332:  CLRF   71
0333:  MOVF   71,W
0334:  SUBLW  0F
0335:  BTFSS  03.0
0336:  GOTO   33F
....................    numberphone[i]=' ';  
0337:  MOVLW  60
0338:  ADDWF  71,W
0339:  MOVWF  04
033A:  BCF    03.7
033B:  MOVLW  20
033C:  MOVWF  00
033D:  INCF   71,F
033E:  GOTO   333
.................... } 
.................... //ham xoa buffer sms 
.................... void smsInit(){ 
.................... //for(i=0;i<smssize;i++) 
....................  smstext[0]=0; 
*
07E1:  BSF    03.5
07E2:  CLRF   20
.................... for(i=0;i<numbersize;i++) 
07E3:  CLRF   71
07E4:  MOVF   71,W
07E5:  SUBLW  0F
07E6:  BTFSS  03.0
07E7:  GOTO   7F0
....................    numberphone[i]=' ';  
07E8:  MOVLW  60
07E9:  ADDWF  71,W
07EA:  MOVWF  04
07EB:  BCF    03.7
07EC:  MOVLW  20
07ED:  MOVWF  00
07EE:  INCF   71,F
07EF:  GOTO   7E4
.................... newsms=0; 
07F0:  CLRF   7B
.................... smsmode=0; 
07F1:  CLRF   7D
.................... smscount=0; 
07F2:  CLRF   7E
.................... } 
07F3:  BCF    03.5
07F4:  BCF    0A.3
07F5:  BSF    0A.4
07F6:  GOTO   111 (RETURN)
.................... //ham gui 1 lenh toi sim900 
.................... void sendCommand(char *AT_cmd){ 
.................... RxInit(); 
.................... delay_ms(800); 
*
033F:  MOVLW  04
0340:  BSF    03.6
0341:  MOVWF  33
0342:  MOVLW  C8
0343:  MOVWF  6C
0344:  BCF    03.6
0345:  CALL   2C2
0346:  BSF    03.6
0347:  DECFSZ 33,F
0348:  GOTO   342
.................... printf("%s\r\n",AT_cmd); 
0349:  MOVF   31,W
034A:  MOVWF  04
034B:  BCF    03.7
034C:  BTFSC  32.0
034D:  BSF    03.7
034E:  BCF    03.6
034F:  CALL   312
0350:  MOVLW  0D
0351:  BTFSS  0C.4
0352:  GOTO   351
0353:  MOVWF  19
0354:  MOVLW  0A
0355:  BTFSS  0C.4
0356:  GOTO   355
0357:  MOVWF  19
.................... } 
0358:  RETURN
.................... //ham so sanh ket qua tra ve cua sim900 voi 1 chuoi 
.................... int IsStringReceived(char *compare_string) 
.................... { 
....................  do{ 
....................    delay_ms(800); 
*
0B32:  MOVLW  04
0B33:  BSF    03.6
0B34:  MOVWF  33
0B35:  MOVLW  C8
0B36:  MOVWF  6C
0B37:  BCF    0A.3
0B38:  BCF    03.6
0B39:  CALL   2C2
0B3A:  BSF    0A.3
0B3B:  BSF    03.6
0B3C:  DECFSZ 33,F
0B3D:  GOTO   335
....................   ret_val=strstr(RxBuf,compare_string);     
0B3E:  CLRF   35
0B3F:  MOVLW  29
0B40:  MOVWF  34
0B41:  MOVF   32,W
0B42:  MOVWF  37
0B43:  MOVF   31,W
0B44:  MOVWF  36
0B45:  BCF    0A.3
0B46:  BCF    03.6
0B47:  CALL   516
0B48:  BSF    0A.3
0B49:  MOVF   79,W
0B4A:  BSF    03.5
0B4B:  MOVWF  6A
0B4C:  MOVF   78,W
0B4D:  MOVWF  69
....................   }while(RxHead==0); 
0B4E:  MOVF   70,F
0B4F:  BTFSS  03.2
0B50:  GOTO   353
0B51:  BCF    03.5
0B52:  GOTO   332
....................   if(ret_val!=0)return 1; 
0B53:  MOVF   69,F
0B54:  BTFSS  03.2
0B55:  GOTO   359
0B56:  MOVF   6A,F
0B57:  BTFSC  03.2
0B58:  GOTO   35C
0B59:  MOVLW  01
0B5A:  MOVWF  78
0B5B:  GOTO   35E
....................  return 0; 
0B5C:  MOVLW  00
0B5D:  MOVWF  78
.................... } 
0B5E:  BCF    03.5
0B5F:  RETURN
.................... void UART_ISR()//source from MDK8051 project 
.................... {      
....................    c=getc(); 
*
0241:  BTFSS  0C.5
0242:  GOTO   241
0243:  MOVF   1A,W
0244:  CLRF   7A
0245:  BSF    03.5
0246:  MOVWF  67
0247:  MOVF   7A,W
0248:  MOVWF  68
....................    //if(calling){ 
....................    if (RxHead < RXBUFSIZE-1){// check for wrap around. 
0249:  MOVF   70,W
024A:  SUBLW  35
024B:  BTFSS  03.0
024C:  GOTO   259
....................       RxBuf[RxHead] = c; 
024D:  MOVLW  29
024E:  ADDWF  70,W
024F:  MOVWF  04
0250:  BCF    03.7
0251:  MOVF   67,W
0252:  MOVWF  00
....................       RxHead ++;          
0253:  INCF   70,F
....................       RxBuf[RxHead] = 0; 
0254:  MOVLW  29
0255:  ADDWF  70,W
0256:  MOVWF  04
0257:  BCF    03.7
0258:  CLRF   00
....................    } 
....................    if(c=='+')startsms=1; 
0259:  MOVF   67,W
025A:  SUBLW  2B
025B:  BTFSS  03.2
025C:  GOTO   262
025D:  MOVF   68,F
025E:  BTFSS  03.2
025F:  GOTO   262
0260:  MOVLW  01
0261:  MOVWF  74
....................    if(startsms==1&&c=='C')startsms=2; 
0262:  DECFSZ 74,W
0263:  GOTO   26D
0264:  MOVF   67,W
0265:  SUBLW  43
0266:  BTFSS  03.2
0267:  GOTO   26D
0268:  MOVF   68,F
0269:  BTFSS  03.2
026A:  GOTO   26D
026B:  MOVLW  02
026C:  MOVWF  74
....................    if(startsms==2&&c=='M')startsms=3; 
026D:  MOVF   74,W
026E:  SUBLW  02
026F:  BTFSS  03.2
0270:  GOTO   27A
0271:  MOVF   67,W
0272:  SUBLW  4D
0273:  BTFSS  03.2
0274:  GOTO   27A
0275:  MOVF   68,F
0276:  BTFSS  03.2
0277:  GOTO   27A
0278:  MOVLW  03
0279:  MOVWF  74
....................    if(startsms==3&&c=='T')startsms=4; 
027A:  MOVF   74,W
027B:  SUBLW  03
027C:  BTFSS  03.2
027D:  GOTO   287
027E:  MOVF   67,W
027F:  SUBLW  54
0280:  BTFSS  03.2
0281:  GOTO   287
0282:  MOVF   68,F
0283:  BTFSS  03.2
0284:  GOTO   287
0285:  MOVLW  04
0286:  MOVWF  74
....................    if(startsms==4){ 
0287:  MOVF   74,W
0288:  SUBLW  04
0289:  BTFSS  03.2
028A:  GOTO   28F
....................       RxHead=0; 
028B:  CLRF   70
....................       smscount=0; 
028C:  CLRF   7E
....................       smsmode=0;   
028D:  CLRF   7D
....................       startsms=0; 
028E:  CLRF   74
....................    } 
....................       if(smsmode==6) 
028F:  MOVF   7D,W
0290:  SUBLW  06
0291:  BTFSS  03.2
0292:  GOTO   2AB
....................       { 
....................       if(c==';'){ 
0293:  MOVF   67,W
0294:  SUBLW  3B
0295:  BTFSS  03.2
0296:  GOTO   29B
0297:  MOVF   68,F
0298:  BTFSS  03.2
0299:  GOTO   29B
....................          calling=0; 
029A:  CLRF   73
....................       }       
....................       if(smscount<smssize-1){ 
029B:  MOVF   7E,W
029C:  SUBLW  18
029D:  BTFSS  03.0
029E:  GOTO   2AB
....................       smstext[smscount]=c; 
029F:  MOVLW  A0
02A0:  ADDWF  7E,W
02A1:  MOVWF  04
02A2:  BCF    03.7
02A3:  MOVF   67,W
02A4:  MOVWF  00
....................       smscount++; 
02A5:  INCF   7E,F
....................       smstext[smscount]=0; 
02A6:  MOVLW  A0
02A7:  ADDWF  7E,W
02A8:  MOVWF  04
02A9:  BCF    03.7
02AA:  CLRF   00
....................       } 
....................       } 
....................       if(c=='"')smsmode++; 
02AB:  MOVF   67,W
02AC:  SUBLW  22
02AD:  BTFSS  03.2
02AE:  GOTO   2B2
02AF:  MOVF   68,F
02B0:  BTFSC  03.2
02B1:  INCF   7D,F
....................    //} 
.................... } 
.................... void turndevice(){ 
....................    b0=0; 
*
0F8E:  BCF    06.0
....................    delay_ms(800); 
0F8F:  MOVLW  04
0F90:  BSF    03.6
0F91:  MOVWF  1C
0F92:  MOVLW  C8
0F93:  MOVWF  6C
0F94:  BCF    0A.3
0F95:  BCF    03.6
0F96:  CALL   2C2
0F97:  BSF    0A.3
0F98:  BSF    03.6
0F99:  DECFSZ 1C,F
0F9A:  GOTO   792
....................    printf("ATH\r\n");    
0F9B:  MOVLW  15
0F9C:  MOVWF  0D
0F9D:  MOVLW  02
0F9E:  MOVWF  0F
0F9F:  BCF    0A.3
0FA0:  BCF    03.6
0FA1:  CALL   2D6
0FA2:  BSF    0A.3
....................    delay_ms(5000); 
0FA3:  MOVLW  14
0FA4:  BSF    03.6
0FA5:  MOVWF  1C
0FA6:  MOVLW  FA
0FA7:  MOVWF  6C
0FA8:  BCF    0A.3
0FA9:  BCF    03.6
0FAA:  CALL   2C2
0FAB:  BSF    0A.3
0FAC:  BSF    03.6
0FAD:  DECFSZ 1C,F
0FAE:  GOTO   7A6
....................    b0=1; 
0FAF:  BCF    03.6
0FB0:  BSF    06.0
.................... } 
0FB1:  BCF    0A.3
0FB2:  BSF    0A.4
0FB3:  GOTO   159 (RETURN)
.................... void turnled(){ 
.................... led1=1; 
.................... delay_ms(1000); 
.................... led1=0; 
.................... } 
....................  
.................... //ham gui nt toi mot sdt 
.................... void sendsms(char *number_str, char *message_str){ 
....................    printf("AT+CMGS=\""); 
*
0566:  MOVLW  18
0567:  BSF    03.6
0568:  MOVWF  0D
0569:  MOVLW  02
056A:  MOVWF  0F
056B:  BCF    03.6
056C:  CALL   2D6
....................    printf(number_str); 
056D:  BSF    03.6
056E:  MOVF   67,W
056F:  MOVWF  04
0570:  BCF    03.7
0571:  BTFSC  68.0
0572:  BSF    03.7
0573:  BCF    03.6
0574:  CALL   312
....................    printf("\"\r"); 
0575:  MOVLW  22
0576:  BTFSS  0C.4
0577:  GOTO   576
0578:  MOVWF  19
0579:  MOVLW  0D
057A:  BTFSS  0C.4
057B:  GOTO   57A
057C:  MOVWF  19
....................    delay_ms(800); 
057D:  MOVLW  04
057E:  BSF    03.6
057F:  MOVWF  6B
0580:  MOVLW  C8
0581:  MOVWF  6C
0582:  BCF    03.6
0583:  CALL   2C2
0584:  BSF    03.6
0585:  DECFSZ 6B,F
0586:  GOTO   580
....................    printf(message_str); 
0587:  MOVF   69,W
0588:  MOVWF  04
0589:  BCF    03.7
058A:  BTFSC  6A.0
058B:  BSF    03.7
058C:  BCF    03.6
058D:  CALL   312
....................    delay_ms(800); 
058E:  MOVLW  04
058F:  BSF    03.6
0590:  MOVWF  6B
0591:  MOVLW  C8
0592:  MOVWF  6C
0593:  BCF    03.6
0594:  CALL   2C2
0595:  BSF    03.6
0596:  DECFSZ 6B,F
0597:  GOTO   591
....................    putc(26); 
0598:  MOVLW  1A
0599:  BCF    03.6
059A:  BTFSS  0C.4
059B:  GOTO   59A
059C:  MOVWF  19
.................... } 
059D:  RETURN
.................... void themsdt(){ 
....................        p_char1=gsmchr(smstext,smssize,'m',1);//lay so dien thoai trong tin nhan  
*
0800:  BSF    03.6
0801:  CLRF   66
0802:  MOVLW  A0
0803:  MOVWF  65
0804:  MOVLW  1A
0805:  MOVWF  67
0806:  MOVLW  6D
0807:  MOVWF  68
0808:  MOVLW  01
0809:  MOVWF  69
080A:  BCF    0A.3
080B:  BCF    03.6
080C:  CALL   3FF
080D:  BSF    0A.3
080E:  MOVF   78,W
080F:  MOVWF  75
....................        p_char2=gsmchr(smstext,smssize,';',1);    
0810:  BSF    03.6
0811:  CLRF   66
0812:  MOVLW  A0
0813:  MOVWF  65
0814:  MOVLW  1A
0815:  MOVWF  67
0816:  MOVLW  3B
0817:  MOVWF  68
0818:  MOVLW  01
0819:  MOVWF  69
081A:  BCF    0A.3
081B:  BCF    03.6
081C:  CALL   3FF
081D:  BSF    0A.3
081E:  MOVF   78,W
081F:  MOVWF  76
....................       for(i=0;i<15;i++){ 
0820:  CLRF   71
0821:  MOVF   71,W
0822:  SUBLW  0E
0823:  BTFSS  03.0
0824:  GOTO   02D
....................       numtem1[i]=' '; 
0825:  MOVLW  C0
0826:  ADDWF  71,W
0827:  MOVWF  04
0828:  BCF    03.7
0829:  MOVLW  20
082A:  MOVWF  00
....................       } 
082B:  INCF   71,F
082C:  GOTO   021
....................        if(p_char1<p_char2){ 
082D:  MOVF   76,W
082E:  SUBWF  75,W
082F:  BTFSC  03.0
0830:  GOTO   11D
....................        for(i=p_char1+1;i<p_char2;i++){ 
0831:  MOVLW  01
0832:  ADDWF  75,W
0833:  MOVWF  71
0834:  MOVF   76,W
0835:  SUBWF  71,W
0836:  BTFSC  03.0
0837:  GOTO   051
....................        numtem1[i-p_char1-1]=smstext[i]; 
0838:  MOVF   75,W
0839:  SUBWF  71,W
083A:  ADDLW  FF
083B:  ADDLW  C0
083C:  BSF    03.6
083D:  MOVWF  65
083E:  CLRF   66
083F:  BTFSC  03.0
0840:  INCF   66,F
0841:  MOVLW  A0
0842:  ADDWF  71,W
0843:  MOVWF  04
0844:  BCF    03.7
0845:  MOVF   00,W
0846:  MOVWF  67
0847:  MOVF   65,W
0848:  MOVWF  04
0849:  BCF    03.7
084A:  BTFSC  66.0
084B:  BSF    03.7
084C:  MOVF   67,W
084D:  MOVWF  00
....................        }       
084E:  INCF   71,F
084F:  BCF    03.6
0850:  GOTO   034
....................       admin=0; 
0851:  CLRF   7C
....................       for(i=1;i<5;i++) 
0852:  MOVLW  01
0853:  MOVWF  71
0854:  MOVF   71,W
0855:  SUBLW  04
0856:  BTFSS  03.0
0857:  GOTO   066
....................          if(numfull[i]=='0'){ 
0858:  MOVLW  BA
0859:  ADDWF  71,W
085A:  MOVWF  04
085B:  BCF    03.7
085C:  MOVF   00,W
085D:  SUBLW  30
085E:  BTFSS  03.2
085F:  GOTO   064
....................          admin=i; 
0860:  MOVF   71,W
0861:  MOVWF  7C
....................          i=5; 
0862:  MOVLW  05
0863:  MOVWF  71
....................          } 
0864:  INCF   71,F
0865:  GOTO   054
....................       if(admin>0){ 
0866:  MOVF   7C,F
0867:  BTFSC  03.2
0868:  GOTO   102
....................        switch(admin){    //ghi so dien thoai vao vi tri trong 
0869:  MOVLW  01
086A:  SUBWF  7C,W
086B:  ADDLW  FC
086C:  BTFSC  03.0
086D:  GOTO   0AC
086E:  ADDLW  04
086F:  GOTO   120
....................        case 1:eeprom_write_string(0x20,numtem1); 
0870:  MOVLW  20
0871:  BSF    03.6
0872:  MOVWF  65
0873:  CLRF   67
0874:  MOVLW  C0
0875:  MOVWF  66
0876:  BCF    0A.3
0877:  BCF    03.6
0878:  CALL   59E
0879:  BSF    0A.3
....................        numfull[1]='1'; 
087A:  MOVLW  31
087B:  BSF    03.5
087C:  MOVWF  3B
....................        break; 
087D:  BCF    03.5
087E:  GOTO   0AC
....................        case 2:eeprom_write_string(0x30,numtem1);               
087F:  MOVLW  30
0880:  BSF    03.6
0881:  MOVWF  65
0882:  CLRF   67
0883:  MOVLW  C0
0884:  MOVWF  66
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   59E
0888:  BSF    0A.3
....................        numfull[2]='1'; 
0889:  MOVLW  31
088A:  BSF    03.5
088B:  MOVWF  3C
....................        break; 
088C:  BCF    03.5
088D:  GOTO   0AC
....................        case 3:eeprom_write_string(0x40,numtem1); 
088E:  MOVLW  40
088F:  BSF    03.6
0890:  MOVWF  65
0891:  CLRF   67
0892:  MOVLW  C0
0893:  MOVWF  66
0894:  BCF    0A.3
0895:  BCF    03.6
0896:  CALL   59E
0897:  BSF    0A.3
....................        numfull[3]='1'; 
0898:  MOVLW  31
0899:  BSF    03.5
089A:  MOVWF  3D
....................        break; 
089B:  BCF    03.5
089C:  GOTO   0AC
....................        case 4:eeprom_write_string(0x50,numtem1); 
089D:  MOVLW  50
089E:  BSF    03.6
089F:  MOVWF  65
08A0:  CLRF   67
08A1:  MOVLW  C0
08A2:  MOVWF  66
08A3:  BCF    0A.3
08A4:  BCF    03.6
08A5:  CALL   59E
08A6:  BSF    0A.3
....................        numfull[4]='1'; 
08A7:  MOVLW  31
08A8:  BSF    03.5
08A9:  MOVWF  3E
....................        break; 
08AA:  BCF    03.5
08AB:  GOTO   0AC
....................        }      
....................        eeprom_write_string(0x00,numfull);//ghi lai trang thai danh sach 
08AC:  BSF    03.6
08AD:  CLRF   65
08AE:  CLRF   67
08AF:  MOVLW  BA
08B0:  MOVWF  66
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   59E
08B4:  BSF    0A.3
....................        strcpy(RxBuf,msg3); 
08B5:  BSF    03.6
08B6:  CLRF   65
08B7:  CLRF   66
08B8:  MOVLW  29
08B9:  MOVWF  04
08BA:  BCF    03.7
08BB:  MOVF   65,W
08BC:  ADDWF  04,F
08BD:  MOVF   66,W
08BE:  BCF    0A.3
08BF:  BCF    03.6
08C0:  CALL   14B
08C1:  BSF    0A.3
08C2:  MOVWF  00
08C3:  IORLW  00
08C4:  BTFSC  03.2
08C5:  GOTO   0CB
08C6:  BSF    03.6
08C7:  INCF   66,F
08C8:  INCF   65,F
08C9:  GOTO   0B8
08CA:  BCF    03.6
....................        for(i=8;i<23;i++){ 
08CB:  MOVLW  08
08CC:  MOVWF  71
08CD:  MOVF   71,W
08CE:  SUBLW  16
08CF:  BTFSS  03.0
08D0:  GOTO   0F6
....................           RxBuf[i]=numtem1[i-8]; 
08D1:  MOVLW  29
08D2:  ADDWF  71,W
08D3:  BSF    03.6
08D4:  MOVWF  65
08D5:  CLRF   66
08D6:  BTFSC  03.0
08D7:  INCF   66,F
08D8:  MOVLW  08
08D9:  SUBWF  71,W
08DA:  ADDLW  C0
08DB:  MOVWF  04
08DC:  BCF    03.7
08DD:  MOVF   00,W
08DE:  MOVWF  67
08DF:  MOVF   65,W
08E0:  MOVWF  04
08E1:  BCF    03.7
08E2:  BTFSC  66.0
08E3:  BSF    03.7
08E4:  MOVF   67,W
08E5:  MOVWF  00
....................        if(RxBuf[i]==' ')RxBuf[i]=0; 
08E6:  MOVLW  29
08E7:  ADDWF  71,W
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  MOVF   00,W
08EB:  SUBLW  20
08EC:  BTFSS  03.2
08ED:  GOTO   0F3
08EE:  MOVLW  29
08EF:  ADDWF  71,W
08F0:  MOVWF  04
08F1:  BCF    03.7
08F2:  CLRF   00
....................        } 
08F3:  INCF   71,F
08F4:  BCF    03.6
08F5:  GOTO   0CD
....................        sendsms(numberphone,RxBuf);//da them        
08F6:  BSF    03.6
08F7:  CLRF   68
08F8:  MOVLW  60
08F9:  MOVWF  67
08FA:  CLRF   6A
08FB:  MOVLW  29
08FC:  MOVWF  69
08FD:  BCF    0A.3
08FE:  BCF    03.6
08FF:  CALL   566
0900:  BSF    0A.3
....................        //turnled(); 
....................        }else sendsms(numberphone,msg1);//neu danh sach full thi gui nt bao nguoi dung xoa bot            
0901:  GOTO   11D
0902:  CLRF   79
0903:  MOVLW  49
0904:  MOVWF  78
0905:  MOVLW  1C
0906:  MOVWF  04
0907:  BSF    03.7
0908:  MOVF   79,W
0909:  BCF    0A.3
090A:  CALL   0DE
090B:  BSF    0A.3
090C:  MOVWF  00
090D:  INCF   79,F
090E:  INCF   04,F
090F:  DECFSZ 78,F
0910:  GOTO   108
0911:  BSF    03.6
0912:  CLRF   68
0913:  MOVLW  60
0914:  MOVWF  67
0915:  MOVLW  01
0916:  MOVWF  6A
0917:  MOVLW  1C
0918:  MOVWF  69
0919:  BCF    0A.3
091A:  BCF    03.6
091B:  CALL   566
091C:  BSF    0A.3
....................      }  
.................... } 
091D:  BCF    0A.3
091E:  BSF    0A.4
091F:  GOTO   0E7 (RETURN)
.................... void xoasdt(){ 
*
0928:  BSF    03.6
0929:  CLRF   1C
.................... int t=0; 
....................          //eeprom_read_string(0x00,numfull,5); 
....................          p_char1=gsmchr(smstext,smssize,'a',1);//lay so dien thoai trong tin nhan  
092A:  CLRF   66
092B:  MOVLW  A0
092C:  MOVWF  65
092D:  MOVLW  1A
092E:  MOVWF  67
092F:  MOVLW  61
0930:  MOVWF  68
0931:  MOVLW  01
0932:  MOVWF  69
0933:  BCF    0A.3
0934:  BCF    03.6
0935:  CALL   3FF
0936:  BSF    0A.3
0937:  MOVF   78,W
0938:  MOVWF  75
....................          p_char2=gsmchr(smstext,smssize,';',1);  
0939:  BSF    03.6
093A:  CLRF   66
093B:  MOVLW  A0
093C:  MOVWF  65
093D:  MOVLW  1A
093E:  MOVWF  67
093F:  MOVLW  3B
0940:  MOVWF  68
0941:  MOVLW  01
0942:  MOVWF  69
0943:  BCF    0A.3
0944:  BCF    03.6
0945:  CALL   3FF
0946:  BSF    0A.3
0947:  MOVF   78,W
0948:  MOVWF  76
....................           for(i=0;i<15;i++){ 
0949:  CLRF   71
094A:  MOVF   71,W
094B:  SUBLW  0E
094C:  BTFSS  03.0
094D:  GOTO   156
....................             numtem1[i]=' '; 
094E:  MOVLW  C0
094F:  ADDWF  71,W
0950:  MOVWF  04
0951:  BCF    03.7
0952:  MOVLW  20
0953:  MOVWF  00
....................           } 
0954:  INCF   71,F
0955:  GOTO   14A
....................          if(p_char1<p_char2){     
0956:  MOVF   76,W
0957:  SUBWF  75,W
0958:  BTFSC  03.0
0959:  GOTO   242
....................          for(i=p_char1+1;i<p_char2;i++){ 
095A:  MOVLW  01
095B:  ADDWF  75,W
095C:  MOVWF  71
095D:  MOVF   76,W
095E:  SUBWF  71,W
095F:  BTFSC  03.0
0960:  GOTO   17E
....................          numtem1[i-p_char1-1]=smstext[i]; 
0961:  MOVF   75,W
0962:  SUBWF  71,W
0963:  ADDLW  FF
0964:  ADDLW  C0
0965:  MOVWF  78
0966:  CLRF   7A
0967:  BTFSC  03.0
0968:  INCF   7A,F
0969:  MOVF   78,W
096A:  BSF    03.6
096B:  MOVWF  36
096C:  MOVF   7A,W
096D:  MOVWF  37
096E:  MOVLW  A0
096F:  ADDWF  71,W
0970:  MOVWF  04
0971:  BCF    03.7
0972:  MOVF   00,W
0973:  MOVWF  38
0974:  MOVF   36,W
0975:  MOVWF  04
0976:  BCF    03.7
0977:  BTFSC  37.0
0978:  BSF    03.7
0979:  MOVF   38,W
097A:  MOVWF  00
....................          }      
097B:  INCF   71,F
097C:  BCF    03.6
097D:  GOTO   15D
....................           
....................          admin=0;  
097E:  CLRF   7C
....................          for(i=1;i<5;i++) 
097F:  MOVLW  01
0980:  MOVWF  71
0981:  MOVF   71,W
0982:  SUBLW  04
0983:  BTFSS  03.0
0984:  GOTO   1CA
....................          if(numfull[i]=='1'){ //so sanh vs sdt trong danh sach 
0985:  MOVLW  BA
0986:  ADDWF  71,W
0987:  MOVWF  04
0988:  BCF    03.7
0989:  MOVF   00,W
098A:  SUBLW  31
098B:  BTFSS  03.2
098C:  GOTO   1C8
....................            eeprom_read_string(16*(i+1),numtem,15);            
098D:  MOVLW  01
098E:  ADDWF  71,W
098F:  MOVWF  77
0990:  SWAPF  77,W
0991:  BSF    03.6
0992:  MOVWF  36
0993:  MOVLW  F0
0994:  ANDWF  36,F
0995:  MOVF   36,W
0996:  MOVWF  5D
0997:  CLRF   5F
0998:  MOVLW  D0
0999:  MOVWF  5E
099A:  MOVLW  0F
099B:  MOVWF  60
099C:  BCF    0A.3
099D:  BCF    03.6
099E:  CALL   41D
099F:  BSF    0A.3
....................             for(t=0;t<15;t++){ 
09A0:  BSF    03.6
09A1:  CLRF   1C
09A2:  MOVF   1C,W
09A3:  SUBLW  0E
09A4:  BTFSS  03.0
09A5:  GOTO   1C7
....................             if(numtem1[t]==numtem[t]){           
09A6:  MOVLW  C0
09A7:  ADDWF  1C,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  MOVF   00,W
09AB:  MOVWF  36
09AC:  MOVLW  D0
09AD:  ADDWF  1C,W
09AE:  MOVWF  04
09AF:  BCF    03.7
09B0:  MOVF   00,W
09B1:  SUBWF  36,W
09B2:  BTFSS  03.2
09B3:  GOTO   1C5
....................             if(numtem[t]==' '){ 
09B4:  MOVLW  D0
09B5:  ADDWF  1C,W
09B6:  MOVWF  04
09B7:  BCF    03.7
09B8:  MOVF   00,W
09B9:  SUBLW  20
09BA:  BTFSS  03.2
09BB:  GOTO   1C5
....................                numfull[i]='0'; 
09BC:  MOVLW  BA
09BD:  ADDWF  71,W
09BE:  MOVWF  04
09BF:  BCF    03.7
09C0:  MOVLW  30
09C1:  MOVWF  00
....................                admin=i;                
09C2:  MOVF   71,W
09C3:  MOVWF  7C
....................                break; 
09C4:  GOTO   1C7
....................             }             
....................             } 
....................           } 
09C5:  INCF   1C,F
09C6:  GOTO   1A2
09C7:  BCF    03.6
....................          } 
09C8:  INCF   71,F
09C9:  GOTO   181
....................           if(admin==0) sendsms(numberphone,msg2);//khong dung sdt 
09CA:  MOVF   7C,F
09CB:  BTFSS  03.2
09CC:  GOTO   1E9
09CD:  CLRF   79
09CE:  MOVLW  19
09CF:  MOVWF  78
09D0:  MOVLW  1D
09D1:  MOVWF  04
09D2:  BSF    03.7
09D3:  MOVF   79,W
09D4:  BCF    0A.3
09D5:  CALL   12E
09D6:  BSF    0A.3
09D7:  MOVWF  00
09D8:  INCF   79,F
09D9:  INCF   04,F
09DA:  DECFSZ 78,F
09DB:  GOTO   1D3
09DC:  BSF    03.6
09DD:  CLRF   68
09DE:  MOVLW  60
09DF:  MOVWF  67
09E0:  MOVLW  01
09E1:  MOVWF  6A
09E2:  MOVLW  1D
09E3:  MOVWF  69
09E4:  BCF    0A.3
09E5:  BCF    03.6
09E6:  CALL   566
09E7:  BSF    0A.3
....................           else { 
09E8:  GOTO   242
....................           eeprom_write_string(0x00,numfull);//ghi lai trang thai danh sach 
09E9:  BSF    03.6
09EA:  CLRF   65
09EB:  CLRF   67
09EC:  MOVLW  BA
09ED:  MOVWF  66
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   59E
09F1:  BSF    0A.3
....................           strcpy(RxBuf,msg4); 
09F2:  BSF    03.6
09F3:  CLRF   36
09F4:  CLRF   37
09F5:  MOVLW  29
09F6:  MOVWF  04
09F7:  BCF    03.7
09F8:  MOVF   36,W
09F9:  ADDWF  04,F
09FA:  MOVF   37,W
09FB:  BCF    0A.3
09FC:  BCF    03.6
09FD:  CALL   158
09FE:  BSF    0A.3
09FF:  MOVWF  00
0A00:  IORLW  00
0A01:  BTFSC  03.2
0A02:  GOTO   208
0A03:  BSF    03.6
0A04:  INCF   37,F
0A05:  INCF   36,F
0A06:  GOTO   1F5
0A07:  BCF    03.6
....................           for(i=8;i<23;i++){ 
0A08:  MOVLW  08
0A09:  MOVWF  71
0A0A:  MOVF   71,W
0A0B:  SUBLW  16
0A0C:  BTFSS  03.0
0A0D:  GOTO   237
....................              RxBuf[i]=numtem1[i-8]; 
0A0E:  MOVLW  29
0A0F:  ADDWF  71,W
0A10:  MOVWF  78
0A11:  CLRF   7A
0A12:  BTFSC  03.0
0A13:  INCF   7A,F
0A14:  MOVF   78,W
0A15:  BSF    03.6
0A16:  MOVWF  36
0A17:  MOVF   7A,W
0A18:  MOVWF  37
0A19:  MOVLW  08
0A1A:  SUBWF  71,W
0A1B:  ADDLW  C0
0A1C:  MOVWF  04
0A1D:  BCF    03.7
0A1E:  MOVF   00,W
0A1F:  MOVWF  38
0A20:  MOVF   36,W
0A21:  MOVWF  04
0A22:  BCF    03.7
0A23:  BTFSC  37.0
0A24:  BSF    03.7
0A25:  MOVF   38,W
0A26:  MOVWF  00
....................              if(RxBuf[i]==' ')RxBuf[i]=0; 
0A27:  MOVLW  29
0A28:  ADDWF  71,W
0A29:  MOVWF  04
0A2A:  BCF    03.7
0A2B:  MOVF   00,W
0A2C:  SUBLW  20
0A2D:  BTFSS  03.2
0A2E:  GOTO   234
0A2F:  MOVLW  29
0A30:  ADDWF  71,W
0A31:  MOVWF  04
0A32:  BCF    03.7
0A33:  CLRF   00
....................              } 
0A34:  INCF   71,F
0A35:  BCF    03.6
0A36:  GOTO   20A
....................          //strcat(RxBuf,numtem1); 
....................           sendsms(numberphone,RxBuf);//da xoa 
0A37:  BSF    03.6
0A38:  CLRF   68
0A39:  MOVLW  60
0A3A:  MOVWF  67
0A3B:  CLRF   6A
0A3C:  MOVLW  29
0A3D:  MOVWF  69
0A3E:  BCF    0A.3
0A3F:  BCF    03.6
0A40:  CALL   566
0A41:  BSF    0A.3
....................           }           
....................      }           
.................... } 
0A42:  BCF    0A.3
0A43:  BSF    0A.4
0A44:  GOTO   0E7 (RETURN)
.................... void doimktk(){ 
0A45:  BSF    03.6
0A46:  CLRF   1C
....................    int t=0; 
....................    p_char1=gsmchr(smstext,smssize,'k',1);//lay so dien thoai trong tin nhan  
0A47:  CLRF   66
0A48:  MOVLW  A0
0A49:  MOVWF  65
0A4A:  MOVLW  1A
0A4B:  MOVWF  67
0A4C:  MOVLW  6B
0A4D:  MOVWF  68
0A4E:  MOVLW  01
0A4F:  MOVWF  69
0A50:  BCF    0A.3
0A51:  BCF    03.6
0A52:  CALL   3FF
0A53:  BSF    0A.3
0A54:  MOVF   78,W
0A55:  MOVWF  75
....................        p_char2=gsmchr(smstext,smssize,'*',1);  
0A56:  BSF    03.6
0A57:  CLRF   66
0A58:  MOVLW  A0
0A59:  MOVWF  65
0A5A:  MOVLW  1A
0A5B:  MOVWF  67
0A5C:  MOVLW  2A
0A5D:  MOVWF  68
0A5E:  MOVLW  01
0A5F:  MOVWF  69
0A60:  BCF    0A.3
0A61:  BCF    03.6
0A62:  CALL   3FF
0A63:  BSF    0A.3
0A64:  MOVF   78,W
0A65:  MOVWF  76
....................  
....................        if(p_char2>p_char1){ 
0A66:  MOVF   76,W
0A67:  SUBWF  75,W
0A68:  BTFSC  03.0
0A69:  GOTO   32F
....................        eeprom_read_string(0x60,mk,6);//doc mk tu bo nho 
0A6A:  MOVLW  60
0A6B:  BSF    03.6
0A6C:  MOVWF  5D
0A6D:  CLRF   5F
0A6E:  MOVLW  E0
0A6F:  MOVWF  5E
0A70:  MOVLW  06
0A71:  MOVWF  60
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   41D
0A75:  BSF    0A.3
....................        for(t=0;t<6;t++)       
0A76:  BSF    03.6
0A77:  CLRF   1C
0A78:  MOVF   1C,W
0A79:  SUBLW  05
0A7A:  BTFSS  03.0
0A7B:  GOTO   28E
....................          if(smstext[p_char1+t+1]!=mk[t])break; 
0A7C:  MOVF   1C,W
0A7D:  ADDWF  75,W
0A7E:  ADDLW  01
0A7F:  ADDLW  A0
0A80:  MOVWF  04
0A81:  BCF    03.7
0A82:  MOVF   00,W
0A83:  MOVWF  5D
0A84:  MOVLW  E0
0A85:  ADDWF  1C,W
0A86:  MOVWF  04
0A87:  BCF    03.7
0A88:  MOVF   00,W
0A89:  SUBWF  5D,W
0A8A:  BTFSS  03.2
0A8B:  GOTO   28E
0A8C:  INCF   1C,F
0A8D:  GOTO   278
....................        if(t==6){ 
0A8E:  MOVF   1C,W
0A8F:  SUBLW  06
0A90:  BTFSS  03.2
0A91:  GOTO   310
....................        p_char1=gsmchr(smstext,smssize,';',1); 
0A92:  CLRF   66
0A93:  MOVLW  A0
0A94:  MOVWF  65
0A95:  MOVLW  1A
0A96:  MOVWF  67
0A97:  MOVLW  3B
0A98:  MOVWF  68
0A99:  MOVLW  01
0A9A:  MOVWF  69
0A9B:  BCF    0A.3
0A9C:  BCF    03.6
0A9D:  CALL   3FF
0A9E:  BSF    0A.3
0A9F:  MOVF   78,W
0AA0:  MOVWF  75
....................        t=p_char1-p_char2;        
0AA1:  MOVF   76,W
0AA2:  SUBWF  75,W
0AA3:  BSF    03.6
0AA4:  MOVWF  1C
....................        if(t==7){ 
0AA5:  MOVF   1C,W
0AA6:  SUBLW  07
0AA7:  BTFSS  03.2
0AA8:  GOTO   2EF
....................           for(t=0;t<6;t++) 
0AA9:  CLRF   1C
0AAA:  MOVF   1C,W
0AAB:  SUBLW  05
0AAC:  BTFSS  03.0
0AAD:  GOTO   2C9
....................             mk[t]=smstext[p_char2+t+1]; 
0AAE:  MOVLW  E0
0AAF:  ADDWF  1C,W
0AB0:  MOVWF  78
0AB1:  CLRF   7A
0AB2:  BTFSC  03.0
0AB3:  INCF   7A,F
0AB4:  MOVF   78,W
0AB5:  MOVWF  5D
0AB6:  MOVF   7A,W
0AB7:  MOVWF  5E
0AB8:  MOVF   1C,W
0AB9:  ADDWF  76,W
0ABA:  ADDLW  01
0ABB:  ADDLW  A0
0ABC:  MOVWF  04
0ABD:  BCF    03.7
0ABE:  MOVF   00,W
0ABF:  MOVWF  5F
0AC0:  MOVF   5D,W
0AC1:  MOVWF  04
0AC2:  BCF    03.7
0AC3:  BTFSC  5E.0
0AC4:  BSF    03.7
0AC5:  MOVF   5F,W
0AC6:  MOVWF  00
0AC7:  INCF   1C,F
0AC8:  GOTO   2AA
....................           eeprom_write_string(0x60,mk); 
0AC9:  MOVLW  60
0ACA:  MOVWF  65
0ACB:  CLRF   67
0ACC:  MOVLW  E0
0ACD:  MOVWF  66
0ACE:  BCF    0A.3
0ACF:  BCF    03.6
0AD0:  CALL   59E
0AD1:  BSF    0A.3
....................           sendsms(numberphone,msg7);//doi mat khau thanh cong 
0AD2:  CLRF   79
0AD3:  MOVLW  18
0AD4:  MOVWF  78
0AD5:  MOVLW  1D
0AD6:  MOVWF  04
0AD7:  BSF    03.7
0AD8:  MOVF   79,W
0AD9:  BCF    0A.3
0ADA:  CALL   195
0ADB:  BSF    0A.3
0ADC:  MOVWF  00
0ADD:  INCF   79,F
0ADE:  INCF   04,F
0ADF:  DECFSZ 78,F
0AE0:  GOTO   2D8
0AE1:  BSF    03.6
0AE2:  CLRF   68
0AE3:  MOVLW  60
0AE4:  MOVWF  67
0AE5:  MOVLW  01
0AE6:  MOVWF  6A
0AE7:  MOVLW  1D
0AE8:  MOVWF  69
0AE9:  BCF    0A.3
0AEA:  BCF    03.6
0AEB:  CALL   566
0AEC:  BSF    0A.3
....................        }else sendsms(numberphone,msg5);//mat khau 6 ky tu 
0AED:  GOTO   30E
0AEE:  BSF    03.6
0AEF:  CLRF   79
0AF0:  MOVLW  1B
0AF1:  MOVWF  78
0AF2:  MOVLW  35
0AF3:  MOVWF  04
0AF4:  BSF    03.7
0AF5:  MOVF   79,W
0AF6:  BCF    0A.3
0AF7:  BCF    03.6
0AF8:  CALL   165
0AF9:  BSF    0A.3
0AFA:  MOVWF  00
0AFB:  INCF   79,F
0AFC:  INCF   04,F
0AFD:  DECFSZ 78,F
0AFE:  GOTO   300
0AFF:  GOTO   302
0B00:  BSF    03.6
0B01:  GOTO   2F5
0B02:  BSF    03.6
0B03:  CLRF   68
0B04:  MOVLW  60
0B05:  MOVWF  67
0B06:  MOVLW  01
0B07:  MOVWF  6A
0B08:  MOVLW  35
0B09:  MOVWF  69
0B0A:  BCF    0A.3
0B0B:  BCF    03.6
0B0C:  CALL   566
0B0D:  BSF    0A.3
....................        }else sendsms(numberphone,msg6);//sai mat khau 
0B0E:  GOTO   32F
0B0F:  BSF    03.6
0B10:  CLRF   79
0B11:  MOVLW  0D
0B12:  MOVWF  78
0B13:  MOVLW  50
0B14:  MOVWF  04
0B15:  BSF    03.7
0B16:  MOVF   79,W
0B17:  BCF    0A.3
0B18:  BCF    03.6
0B19:  CALL   184
0B1A:  BSF    0A.3
0B1B:  MOVWF  00
0B1C:  INCF   79,F
0B1D:  INCF   04,F
0B1E:  DECFSZ 78,F
0B1F:  GOTO   321
0B20:  GOTO   323
0B21:  BSF    03.6
0B22:  GOTO   316
0B23:  BSF    03.6
0B24:  CLRF   68
0B25:  MOVLW  60
0B26:  MOVWF  67
0B27:  MOVLW  01
0B28:  MOVWF  6A
0B29:  MOVLW  50
0B2A:  MOVWF  69
0B2B:  BCF    0A.3
0B2C:  BCF    03.6
0B2D:  CALL   566
0B2E:  BSF    0A.3
....................        } 
.................... } 
0B2F:  BCF    0A.3
0B30:  BSF    0A.4
0B31:  GOTO   0E7 (RETURN)
.................... void kttkchinh(){ 
*
0B60:  BSF    03.6
0B61:  CLRF   1C
.................... int t=0; 
....................    sendCommand(setkttk); 
0B62:  CLRF   79
0B63:  MOVLW  0A
0B64:  MOVWF  78
0B65:  MOVLW  1D
0B66:  MOVWF  04
0B67:  BSF    03.7
0B68:  MOVF   79,W
0B69:  BCF    0A.3
0B6A:  BCF    03.6
0B6B:  CALL   04D
0B6C:  BSF    0A.3
0B6D:  MOVWF  00
0B6E:  INCF   79,F
0B6F:  INCF   04,F
0B70:  DECFSZ 78,F
0B71:  GOTO   373
0B72:  GOTO   375
0B73:  BSF    03.6
0B74:  GOTO   368
0B75:  MOVLW  01
0B76:  BSF    03.6
0B77:  MOVWF  32
0B78:  MOVLW  1D
0B79:  MOVWF  31
0B7A:  BCF    0A.3
0B7B:  BCF    03.6
0B7C:  CALL   330
0B7D:  BSF    0A.3
....................        if( IsStringReceived(OK)){ 
0B7E:  MOVLW  4F
0B7F:  BSF    03.6
0B80:  MOVWF  1D
0B81:  MOVLW  4B
0B82:  MOVWF  1E
0B83:  CLRF   1F
0B84:  MOVLW  01
0B85:  MOVWF  32
0B86:  MOVLW  1D
0B87:  MOVWF  31
0B88:  BCF    03.6
0B89:  CALL   332
0B8A:  MOVF   78,F
0B8B:  BTFSC  03.2
0B8C:  GOTO   422
....................          sendCommand(kttka); 
0B8D:  CLRF   79
0B8E:  MOVLW  12
0B8F:  MOVWF  78
0B90:  MOVLW  1D
0B91:  MOVWF  04
0B92:  BSF    03.7
0B93:  MOVF   79,W
0B94:  BCF    0A.3
0B95:  CALL   05B
0B96:  BSF    0A.3
0B97:  MOVWF  00
0B98:  INCF   79,F
0B99:  INCF   04,F
0B9A:  DECFSZ 78,F
0B9B:  GOTO   393
0B9C:  MOVLW  01
0B9D:  BSF    03.6
0B9E:  MOVWF  32
0B9F:  MOVLW  1D
0BA0:  MOVWF  31
0BA1:  BCF    0A.3
0BA2:  BCF    03.6
0BA3:  CALL   330
0BA4:  BSF    0A.3
....................          delay_ms(800); 
0BA5:  MOVLW  04
0BA6:  BSF    03.6
0BA7:  MOVWF  2F
0BA8:  MOVLW  C8
0BA9:  MOVWF  6C
0BAA:  BCF    0A.3
0BAB:  BCF    03.6
0BAC:  CALL   2C2
0BAD:  BSF    0A.3
0BAE:  BSF    03.6
0BAF:  DECFSZ 2F,F
0BB0:  GOTO   3A8
....................          t=0; 
0BB1:  CLRF   1C
....................          while(IsStringReceived(cusd)!=1){ 
0BB2:  MOVLW  2B
0BB3:  MOVWF  1D
0BB4:  MOVLW  43
0BB5:  MOVWF  1E
0BB6:  MOVLW  55
0BB7:  MOVWF  1F
0BB8:  MOVLW  53
0BB9:  MOVWF  20
0BBA:  MOVLW  44
0BBB:  MOVWF  21
0BBC:  CLRF   22
0BBD:  MOVLW  01
0BBE:  MOVWF  32
0BBF:  MOVLW  1D
0BC0:  MOVWF  31
0BC1:  BCF    03.6
0BC2:  CALL   332
0BC3:  DECFSZ 78,W
0BC4:  GOTO   3C6
0BC5:  GOTO   3D2
....................          RxHead=0;  
0BC6:  CLRF   70
....................          t++; 
0BC7:  BSF    03.6
0BC8:  INCF   1C,F
....................          if(t==10)break; 
0BC9:  MOVF   1C,W
0BCA:  SUBLW  0A
0BCB:  BTFSS  03.2
0BCC:  GOTO   3D0
0BCD:  BCF    03.6
0BCE:  GOTO   3D2
0BCF:  BSF    03.6
....................          }      
0BD0:  GOTO   3B2
0BD1:  BCF    03.6
....................          if(t<10){ 
0BD2:  BSF    03.6
0BD3:  MOVF   1C,W
0BD4:  SUBLW  09
0BD5:  BTFSS  03.0
0BD6:  GOTO   403
....................             for(i=9;i<15;i++) 
0BD7:  MOVLW  09
0BD8:  MOVWF  71
0BD9:  MOVF   71,W
0BDA:  SUBLW  0E
0BDB:  BTFSS  03.0
0BDC:  GOTO   3EC
....................             if(numtem1[i]==' ')numtem1[i]=0; 
0BDD:  MOVLW  C0
0BDE:  ADDWF  71,W
0BDF:  MOVWF  04
0BE0:  BCF    03.7
0BE1:  MOVF   00,W
0BE2:  SUBLW  20
0BE3:  BTFSS  03.2
0BE4:  GOTO   3EA
0BE5:  MOVLW  C0
0BE6:  ADDWF  71,W
0BE7:  MOVWF  04
0BE8:  BCF    03.7
0BE9:  CLRF   00
0BEA:  INCF   71,F
0BEB:  GOTO   3D9
....................             RxBuf[0]='K'; 
0BEC:  MOVLW  4B
0BED:  BCF    03.6
0BEE:  MOVWF  29
....................             RxBuf[1]='T'; 
0BEF:  MOVLW  54
0BF0:  MOVWF  2A
....................             RxBuf[2]='T'; 
0BF1:  MOVWF  2B
....................             RxBuf[3]='K'; 
0BF2:  MOVLW  4B
0BF3:  MOVWF  2C
....................             RxBuf[4]='1'; 
0BF4:  MOVLW  31
0BF5:  MOVWF  2D
....................          sendsms( numtem1, RxBuf); 
0BF6:  BSF    03.6
0BF7:  CLRF   68
0BF8:  MOVLW  C0
0BF9:  MOVWF  67
0BFA:  CLRF   6A
0BFB:  MOVLW  29
0BFC:  MOVWF  69
0BFD:  BCF    0A.3
0BFE:  BCF    03.6
0BFF:  CALL   566
0C00:  BSF    0A.3
....................          }else sendsms(numtem1,error1); 
0C01:  GOTO   422
0C02:  BSF    03.6
0C03:  CLRF   79
0C04:  MOVLW  11
0C05:  MOVWF  78
0C06:  MOVLW  1D
0C07:  MOVWF  04
0C08:  BSF    03.7
0C09:  MOVF   79,W
0C0A:  BCF    0A.3
0C0B:  BCF    03.6
0C0C:  CALL   038
0C0D:  BSF    0A.3
0C0E:  MOVWF  00
0C0F:  INCF   79,F
0C10:  INCF   04,F
0C11:  DECFSZ 78,F
0C12:  GOTO   414
0C13:  GOTO   416
0C14:  BSF    03.6
0C15:  GOTO   409
0C16:  BSF    03.6
0C17:  CLRF   68
0C18:  MOVLW  C0
0C19:  MOVWF  67
0C1A:  MOVLW  01
0C1B:  MOVWF  6A
0C1C:  MOVLW  1D
0C1D:  MOVWF  69
0C1E:  BCF    0A.3
0C1F:  BCF    03.6
0C20:  CALL   566
0C21:  BSF    0A.3
....................        } 
.................... } 
0C22:  RETURN
.................... void kttkphu(){ 
0C23:  BSF    03.6
0C24:  CLRF   1C
....................    int t=0; 
....................        sendCommand(setkttk); 
0C25:  CLRF   79
0C26:  MOVLW  0A
0C27:  MOVWF  78
0C28:  MOVLW  1D
0C29:  MOVWF  04
0C2A:  BSF    03.7
0C2B:  MOVF   79,W
0C2C:  BCF    0A.3
0C2D:  BCF    03.6
0C2E:  CALL   04D
0C2F:  BSF    0A.3
0C30:  MOVWF  00
0C31:  INCF   79,F
0C32:  INCF   04,F
0C33:  DECFSZ 78,F
0C34:  GOTO   436
0C35:  GOTO   438
0C36:  BSF    03.6
0C37:  GOTO   42B
0C38:  MOVLW  01
0C39:  BSF    03.6
0C3A:  MOVWF  32
0C3B:  MOVLW  1D
0C3C:  MOVWF  31
0C3D:  BCF    0A.3
0C3E:  BCF    03.6
0C3F:  CALL   330
0C40:  BSF    0A.3
....................        if( IsStringReceived(OK)){ 
0C41:  MOVLW  4F
0C42:  BSF    03.6
0C43:  MOVWF  1D
0C44:  MOVLW  4B
0C45:  MOVWF  1E
0C46:  CLRF   1F
0C47:  MOVLW  01
0C48:  MOVWF  32
0C49:  MOVLW  1D
0C4A:  MOVWF  31
0C4B:  BCF    03.6
0C4C:  CALL   332
0C4D:  MOVF   78,F
0C4E:  BTFSC  03.2
0C4F:  GOTO   4E5
....................          sendCommand(kttkb); 
0C50:  CLRF   79
0C51:  MOVLW  12
0C52:  MOVWF  78
0C53:  MOVLW  1D
0C54:  MOVWF  04
0C55:  BSF    03.7
0C56:  MOVF   79,W
0C57:  BCF    0A.3
0C58:  CALL   071
0C59:  BSF    0A.3
0C5A:  MOVWF  00
0C5B:  INCF   79,F
0C5C:  INCF   04,F
0C5D:  DECFSZ 78,F
0C5E:  GOTO   456
0C5F:  MOVLW  01
0C60:  BSF    03.6
0C61:  MOVWF  32
0C62:  MOVLW  1D
0C63:  MOVWF  31
0C64:  BCF    0A.3
0C65:  BCF    03.6
0C66:  CALL   330
0C67:  BSF    0A.3
....................          delay_ms(800); 
0C68:  MOVLW  04
0C69:  BSF    03.6
0C6A:  MOVWF  2F
0C6B:  MOVLW  C8
0C6C:  MOVWF  6C
0C6D:  BCF    0A.3
0C6E:  BCF    03.6
0C6F:  CALL   2C2
0C70:  BSF    0A.3
0C71:  BSF    03.6
0C72:  DECFSZ 2F,F
0C73:  GOTO   46B
....................          t=0; 
0C74:  CLRF   1C
....................          while(IsStringReceived(cusd)!=1){ 
0C75:  MOVLW  2B
0C76:  MOVWF  1D
0C77:  MOVLW  43
0C78:  MOVWF  1E
0C79:  MOVLW  55
0C7A:  MOVWF  1F
0C7B:  MOVLW  53
0C7C:  MOVWF  20
0C7D:  MOVLW  44
0C7E:  MOVWF  21
0C7F:  CLRF   22
0C80:  MOVLW  01
0C81:  MOVWF  32
0C82:  MOVLW  1D
0C83:  MOVWF  31
0C84:  BCF    03.6
0C85:  CALL   332
0C86:  DECFSZ 78,W
0C87:  GOTO   489
0C88:  GOTO   495
....................          RxHead=0;  
0C89:  CLRF   70
....................          t++; 
0C8A:  BSF    03.6
0C8B:  INCF   1C,F
....................          if(t==10)break; 
0C8C:  MOVF   1C,W
0C8D:  SUBLW  0A
0C8E:  BTFSS  03.2
0C8F:  GOTO   493
0C90:  BCF    03.6
0C91:  GOTO   495
0C92:  BSF    03.6
....................          }      
0C93:  GOTO   475
0C94:  BCF    03.6
....................          if(t<10){ 
0C95:  BSF    03.6
0C96:  MOVF   1C,W
0C97:  SUBLW  09
0C98:  BTFSS  03.0
0C99:  GOTO   4C6
....................             for(i=9;i<15;i++) 
0C9A:  MOVLW  09
0C9B:  MOVWF  71
0C9C:  MOVF   71,W
0C9D:  SUBLW  0E
0C9E:  BTFSS  03.0
0C9F:  GOTO   4AF
....................             if(numtem1[i]==' ')numtem1[i]=0; 
0CA0:  MOVLW  C0
0CA1:  ADDWF  71,W
0CA2:  MOVWF  04
0CA3:  BCF    03.7
0CA4:  MOVF   00,W
0CA5:  SUBLW  20
0CA6:  BTFSS  03.2
0CA7:  GOTO   4AD
0CA8:  MOVLW  C0
0CA9:  ADDWF  71,W
0CAA:  MOVWF  04
0CAB:  BCF    03.7
0CAC:  CLRF   00
0CAD:  INCF   71,F
0CAE:  GOTO   49C
....................             RxBuf[0]='K'; 
0CAF:  MOVLW  4B
0CB0:  BCF    03.6
0CB1:  MOVWF  29
....................             RxBuf[1]='T'; 
0CB2:  MOVLW  54
0CB3:  MOVWF  2A
....................             RxBuf[2]='T'; 
0CB4:  MOVWF  2B
....................             RxBuf[3]='K'; 
0CB5:  MOVLW  4B
0CB6:  MOVWF  2C
....................             RxBuf[4]='2'; 
0CB7:  MOVLW  32
0CB8:  MOVWF  2D
....................          sendsms( numtem1, RxBuf); 
0CB9:  BSF    03.6
0CBA:  CLRF   68
0CBB:  MOVLW  C0
0CBC:  MOVWF  67
0CBD:  CLRF   6A
0CBE:  MOVLW  29
0CBF:  MOVWF  69
0CC0:  BCF    0A.3
0CC1:  BCF    03.6
0CC2:  CALL   566
0CC3:  BSF    0A.3
....................          }else sendsms(numtem1,error1); 
0CC4:  GOTO   4E5
0CC5:  BSF    03.6
0CC6:  CLRF   79
0CC7:  MOVLW  11
0CC8:  MOVWF  78
0CC9:  MOVLW  1D
0CCA:  MOVWF  04
0CCB:  BSF    03.7
0CCC:  MOVF   79,W
0CCD:  BCF    0A.3
0CCE:  BCF    03.6
0CCF:  CALL   038
0CD0:  BSF    0A.3
0CD1:  MOVWF  00
0CD2:  INCF   79,F
0CD3:  INCF   04,F
0CD4:  DECFSZ 78,F
0CD5:  GOTO   4D7
0CD6:  GOTO   4D9
0CD7:  BSF    03.6
0CD8:  GOTO   4CC
0CD9:  BSF    03.6
0CDA:  CLRF   68
0CDB:  MOVLW  C0
0CDC:  MOVWF  67
0CDD:  MOVLW  01
0CDE:  MOVWF  6A
0CDF:  MOVLW  1D
0CE0:  MOVWF  69
0CE1:  BCF    0A.3
0CE2:  BCF    03.6
0CE3:  CALL   566
0CE4:  BSF    0A.3
....................        } 
.................... } 
0CE5:  RETURN
.................... int admin1(){ 
*
05D4:  BSF    03.6
05D5:  CLRF   1C
....................    int t=0; 
....................       if(strstr(smstext,them)!=0){  //them 1 so dien thoai       
05D6:  MOVLW  74
05D7:  MOVWF  1D
05D8:  MOVLW  68
05D9:  MOVWF  1E
05DA:  MOVLW  65
05DB:  MOVWF  1F
05DC:  MOVLW  6D
05DD:  MOVWF  20
05DE:  MOVLW  30
05DF:  MOVWF  21
05E0:  CLRF   22
05E1:  CLRF   35
05E2:  MOVLW  A0
05E3:  MOVWF  34
05E4:  MOVLW  01
05E5:  MOVWF  37
05E6:  MOVLW  1D
05E7:  MOVWF  36
05E8:  BCF    03.6
05E9:  CALL   516
05EA:  MOVF   79,W
05EB:  BSF    03.6
05EC:  MOVWF  2C
05ED:  MOVF   78,W
05EE:  MOVWF  2B
05EF:  MOVF   2B,F
05F0:  BTFSS  03.2
05F1:  GOTO   5F5
05F2:  MOVF   2C,F
05F3:  BTFSC  03.2
05F4:  GOTO   5F8
....................          return 1; 
05F5:  MOVLW  01
05F6:  MOVWF  78
05F7:  GOTO   7DD
....................       } 
....................      //xoa sdt trong danh sach 
....................       if(strstr(smstext,xoa)!=0){ 
05F8:  MOVLW  78
05F9:  MOVWF  1D
05FA:  MOVLW  6F
05FB:  MOVWF  1E
05FC:  MOVLW  61
05FD:  MOVWF  1F
05FE:  MOVLW  30
05FF:  MOVWF  20
0600:  CLRF   21
0601:  CLRF   35
0602:  MOVLW  A0
0603:  MOVWF  34
0604:  MOVLW  01
0605:  MOVWF  37
0606:  MOVLW  1D
0607:  MOVWF  36
0608:  BCF    03.6
0609:  CALL   516
060A:  MOVF   79,W
060B:  BSF    03.6
060C:  MOVWF  2C
060D:  MOVF   78,W
060E:  MOVWF  2B
060F:  MOVF   2B,F
0610:  BTFSS  03.2
0611:  GOTO   615
0612:  MOVF   2C,F
0613:  BTFSC  03.2
0614:  GOTO   618
....................          return 2;        
0615:  MOVLW  02
0616:  MOVWF  78
0617:  GOTO   7DD
....................       } 
....................       if(strstr(smstext,doimk)!=0){ 
0618:  MOVLW  64
0619:  MOVWF  1D
061A:  MOVLW  6F
061B:  MOVWF  1E
061C:  MOVLW  69
061D:  MOVWF  1F
061E:  MOVLW  6D
061F:  MOVWF  20
0620:  MOVLW  6B
0621:  MOVWF  21
0622:  CLRF   22
0623:  CLRF   35
0624:  MOVLW  A0
0625:  MOVWF  34
0626:  MOVLW  01
0627:  MOVWF  37
0628:  MOVLW  1D
0629:  MOVWF  36
062A:  BCF    03.6
062B:  CALL   516
062C:  MOVF   79,W
062D:  BSF    03.6
062E:  MOVWF  2C
062F:  MOVF   78,W
0630:  MOVWF  2B
0631:  MOVF   2B,F
0632:  BTFSS  03.2
0633:  GOTO   637
0634:  MOVF   2C,F
0635:  BTFSC  03.2
0636:  GOTO   63A
....................        return 3; 
0637:  MOVLW  03
0638:  MOVWF  78
0639:  GOTO   7DD
....................      } 
....................      if(strstr(smstext, kttk1)!=0){                  
063A:  MOVLW  6B
063B:  MOVWF  1D
063C:  MOVLW  74
063D:  MOVWF  1E
063E:  MOVWF  1F
063F:  MOVLW  6B
0640:  MOVWF  20
0641:  MOVLW  31
0642:  MOVWF  21
0643:  CLRF   22
0644:  CLRF   35
0645:  MOVLW  A0
0646:  MOVWF  34
0647:  MOVLW  01
0648:  MOVWF  37
0649:  MOVLW  1D
064A:  MOVWF  36
064B:  BCF    03.6
064C:  CALL   516
064D:  MOVF   79,W
064E:  BSF    03.6
064F:  MOVWF  2C
0650:  MOVF   78,W
0651:  MOVWF  2B
0652:  MOVF   2B,F
0653:  BTFSS  03.2
0654:  GOTO   658
0655:  MOVF   2C,F
0656:  BTFSC  03.2
0657:  GOTO   65B
....................        return 4;        
0658:  MOVLW  04
0659:  MOVWF  78
065A:  GOTO   7DD
....................        } 
....................       if(strstr(smstext, kttk2)!=0){                  
065B:  MOVLW  6B
065C:  MOVWF  1D
065D:  MOVLW  74
065E:  MOVWF  1E
065F:  MOVWF  1F
0660:  MOVLW  6B
0661:  MOVWF  20
0662:  MOVLW  32
0663:  MOVWF  21
0664:  CLRF   22
0665:  CLRF   35
0666:  MOVLW  A0
0667:  MOVWF  34
0668:  MOVLW  01
0669:  MOVWF  37
066A:  MOVLW  1D
066B:  MOVWF  36
066C:  BCF    03.6
066D:  CALL   516
066E:  MOVF   79,W
066F:  BSF    03.6
0670:  MOVWF  2C
0671:  MOVF   78,W
0672:  MOVWF  2B
0673:  MOVF   2B,F
0674:  BTFSS  03.2
0675:  GOTO   679
0676:  MOVF   2C,F
0677:  BTFSC  03.2
0678:  GOTO   67C
....................         return 5;        
0679:  MOVLW  05
067A:  MOVWF  78
067B:  GOTO   7DD
....................       }   
....................       if(strstr(smstext,quenmk)!=0){//gui lai mat khau 
067C:  CLRF   79
067D:  MOVLW  07
067E:  MOVWF  78
067F:  MOVLW  1D
0680:  MOVWF  04
0681:  BSF    03.7
0682:  MOVF   79,W
0683:  BCF    03.6
0684:  CALL   0D3
0685:  MOVWF  00
0686:  INCF   79,F
0687:  INCF   04,F
0688:  DECFSZ 78,F
0689:  GOTO   68B
068A:  GOTO   68D
068B:  BSF    03.6
068C:  GOTO   682
068D:  BSF    03.6
068E:  CLRF   35
068F:  MOVLW  A0
0690:  MOVWF  34
0691:  MOVLW  01
0692:  MOVWF  37
0693:  MOVLW  1D
0694:  MOVWF  36
0695:  BCF    03.6
0696:  CALL   516
0697:  MOVF   79,W
0698:  BSF    03.6
0699:  MOVWF  2C
069A:  MOVF   78,W
069B:  MOVWF  2B
069C:  MOVF   2B,F
069D:  BTFSS  03.2
069E:  GOTO   6A2
069F:  MOVF   2C,F
06A0:  BTFSC  03.2
06A1:  GOTO   6B6
....................        eeprom_read_string(0x60,mk,6);//doc mk tu bo nho 
06A2:  MOVLW  60
06A3:  MOVWF  5D
06A4:  CLRF   5F
06A5:  MOVLW  E0
06A6:  MOVWF  5E
06A7:  MOVLW  06
06A8:  MOVWF  60
06A9:  BCF    03.6
06AA:  CALL   41D
....................        sendsms(numberphone,mk);        
06AB:  BSF    03.6
06AC:  CLRF   68
06AD:  MOVLW  60
06AE:  MOVWF  67
06AF:  CLRF   6A
06B0:  MOVLW  E0
06B1:  MOVWF  69
06B2:  BCF    03.6
06B3:  CALL   566
....................       }      
....................      else if(strstr(smstext, dssdt)!=0){//lay danh sach sdt 
06B4:  GOTO   7DA
06B5:  BSF    03.6
06B6:  MOVLW  64
06B7:  MOVWF  1D
06B8:  MOVLW  73
06B9:  MOVWF  1E
06BA:  MOVWF  1F
06BB:  MOVLW  64
06BC:  MOVWF  20
06BD:  MOVLW  74
06BE:  MOVWF  21
06BF:  CLRF   22
06C0:  CLRF   35
06C1:  MOVLW  A0
06C2:  MOVWF  34
06C3:  MOVLW  01
06C4:  MOVWF  37
06C5:  MOVLW  1D
06C6:  MOVWF  36
06C7:  BCF    03.6
06C8:  CALL   516
06C9:  MOVF   79,W
06CA:  BSF    03.6
06CB:  MOVWF  2C
06CC:  MOVF   78,W
06CD:  MOVWF  2B
06CE:  MOVF   2B,F
06CF:  BTFSS  03.2
06D0:  GOTO   6D4
06D1:  MOVF   2C,F
06D2:  BTFSC  03.2
06D3:  GOTO   756
....................      strcpy(RxBuf,msg9); 
06D4:  CLRF   29
06D5:  CLRF   2A
06D6:  MOVLW  29
06D7:  MOVWF  04
06D8:  BCF    03.7
06D9:  MOVF   29,W
06DA:  ADDWF  04,F
06DB:  MOVF   2A,W
06DC:  BCF    03.6
06DD:  CALL   097
06DE:  MOVWF  00
06DF:  IORLW  00
06E0:  BTFSC  03.2
06E1:  GOTO   6E7
06E2:  BSF    03.6
06E3:  INCF   2A,F
06E4:  INCF   29,F
06E5:  GOTO   6D6
06E6:  BCF    03.6
....................      RxHead=3; 
06E7:  MOVLW  03
06E8:  MOVWF  70
....................      for(i=1;i<5;i++) 
06E9:  MOVLW  01
06EA:  MOVWF  71
06EB:  MOVF   71,W
06EC:  SUBLW  04
06ED:  BTFSS  03.0
06EE:  GOTO   74B
....................      if(numfull[i]=='1'){ 
06EF:  MOVLW  BA
06F0:  ADDWF  71,W
06F1:  MOVWF  04
06F2:  BCF    03.7
06F3:  MOVF   00,W
06F4:  SUBLW  31
06F5:  BTFSS  03.2
06F6:  GOTO   742
....................        eeprom_read_string((i+1)*16,numtem,15);  
06F7:  MOVLW  01
06F8:  ADDWF  71,W
06F9:  MOVWF  77
06FA:  SWAPF  77,W
06FB:  BSF    03.6
06FC:  MOVWF  29
06FD:  MOVLW  F0
06FE:  ANDWF  29,F
06FF:  MOVF   29,W
0700:  MOVWF  5D
0701:  CLRF   5F
0702:  MOVLW  D0
0703:  MOVWF  5E
0704:  MOVLW  0F
0705:  MOVWF  60
0706:  BCF    03.6
0707:  CALL   41D
....................        for(t=0;t<15;t++){ 
0708:  BSF    03.6
0709:  CLRF   1C
070A:  MOVF   1C,W
070B:  SUBLW  0E
070C:  BTFSS  03.0
070D:  GOTO   740
....................        RxBuf[RxHead++]= numtem[t]; 
070E:  MOVF   70,W
070F:  INCF   70,F
0710:  ADDLW  29
0711:  MOVWF  78
0712:  CLRF   7A
0713:  BTFSC  03.0
0714:  INCF   7A,F
0715:  MOVF   78,W
0716:  MOVWF  29
0717:  MOVF   7A,W
0718:  MOVWF  2A
0719:  MOVLW  D0
071A:  ADDWF  1C,W
071B:  MOVWF  04
071C:  BCF    03.7
071D:  MOVF   00,W
071E:  MOVWF  2B
071F:  MOVF   29,W
0720:  MOVWF  04
0721:  BCF    03.7
0722:  BTFSC  2A.0
0723:  BSF    03.7
0724:  MOVF   2B,W
0725:  MOVWF  00
....................        if(numtem[t]==' '){ 
0726:  MOVLW  D0
0727:  ADDWF  1C,W
0728:  MOVWF  04
0729:  BCF    03.7
072A:  MOVF   00,W
072B:  SUBLW  20
072C:  BTFSS  03.2
072D:  GOTO   73E
....................        RxBuf[RxHead-1]=';'; 
072E:  MOVLW  01
072F:  SUBWF  70,W
0730:  ADDLW  29
0731:  MOVWF  04
0732:  BCF    03.7
0733:  MOVLW  3B
0734:  MOVWF  00
....................        RxBuf[RxHead++]=' '; 
0735:  MOVF   70,W
0736:  INCF   70,F
0737:  ADDLW  29
0738:  MOVWF  04
0739:  BCF    03.7
073A:  MOVLW  20
073B:  MOVWF  00
....................        t=15;         
073C:  MOVLW  0F
073D:  MOVWF  1C
....................        } 
....................        } 
073E:  INCF   1C,F
073F:  GOTO   70A
....................      }else RxBuf[RxHead]=0; 
0740:  GOTO   748
0741:  BCF    03.6
0742:  MOVLW  29
0743:  ADDWF  70,W
0744:  MOVWF  04
0745:  BCF    03.7
0746:  CLRF   00
0747:  BSF    03.6
0748:  INCF   71,F
0749:  BCF    03.6
074A:  GOTO   6EB
....................        sendsms(numberphone,RxBuf);//gui danh sach sdt 
074B:  BSF    03.6
074C:  CLRF   68
074D:  MOVLW  60
074E:  MOVWF  67
074F:  CLRF   6A
0750:  MOVLW  29
0751:  MOVWF  69
0752:  BCF    03.6
0753:  CALL   566
....................      }        
....................       else if(strstr(smstext,xoahet)!=0){ 
0754:  GOTO   7DA
0755:  BSF    03.6
0756:  CLRF   79
0757:  MOVLW  07
0758:  MOVWF  78
0759:  MOVLW  1D
075A:  MOVWF  04
075B:  BSF    03.7
075C:  MOVF   79,W
075D:  BCF    03.6
075E:  CALL   1CA
075F:  MOVWF  00
0760:  INCF   79,F
0761:  INCF   04,F
0762:  DECFSZ 78,F
0763:  GOTO   765
0764:  GOTO   767
0765:  BSF    03.6
0766:  GOTO   75C
0767:  BSF    03.6
0768:  CLRF   35
0769:  MOVLW  A0
076A:  MOVWF  34
076B:  MOVLW  01
076C:  MOVWF  37
076D:  MOVLW  1D
076E:  MOVWF  36
076F:  BCF    03.6
0770:  CALL   516
0771:  MOVF   79,W
0772:  BSF    03.6
0773:  MOVWF  2C
0774:  MOVF   78,W
0775:  MOVWF  2B
0776:  MOVF   2B,F
0777:  BTFSS  03.2
0778:  GOTO   77C
0779:  MOVF   2C,F
077A:  BTFSC  03.2
077B:  GOTO   7BF
....................          for(i=1;i<5;i++) 
077C:  MOVLW  01
077D:  MOVWF  71
077E:  MOVF   71,W
077F:  SUBLW  04
0780:  BTFSS  03.0
0781:  GOTO   78A
....................          numfull[i]='0'; 
0782:  MOVLW  BA
0783:  ADDWF  71,W
0784:  MOVWF  04
0785:  BCF    03.7
0786:  MOVLW  30
0787:  MOVWF  00
0788:  INCF   71,F
0789:  GOTO   77E
....................          eeprom_write_string(0x00,numfull);  
078A:  CLRF   65
078B:  CLRF   67
078C:  MOVLW  BA
078D:  MOVWF  66
078E:  BCF    03.6
078F:  CALL   59E
....................          strcpy(RxBuf,msg4); 
0790:  BSF    03.6
0791:  CLRF   29
0792:  CLRF   2A
0793:  MOVLW  29
0794:  MOVWF  04
0795:  BCF    03.7
0796:  MOVF   29,W
0797:  ADDWF  04,F
0798:  MOVF   2A,W
0799:  BCF    03.6
079A:  CALL   158
079B:  MOVWF  00
079C:  IORLW  00
079D:  BTFSC  03.2
079E:  GOTO   7A4
079F:  BSF    03.6
07A0:  INCF   2A,F
07A1:  INCF   29,F
07A2:  GOTO   793
07A3:  BCF    03.6
....................          RxBuf[6]='!'; 
07A4:  MOVLW  21
07A5:  MOVWF  2F
....................          sendsms(numberphone,msg4);//da xoa 
07A6:  CLRF   79
07A7:  MOVLW  09
07A8:  MOVWF  78
07A9:  MOVLW  1D
07AA:  MOVWF  04
07AB:  BSF    03.7
07AC:  MOVF   79,W
07AD:  CALL   158
07AE:  MOVWF  00
07AF:  INCF   79,F
07B0:  INCF   04,F
07B1:  DECFSZ 78,F
07B2:  GOTO   7AC
07B3:  BSF    03.6
07B4:  CLRF   68
07B5:  MOVLW  60
07B6:  MOVWF  67
07B7:  MOVLW  01
07B8:  MOVWF  6A
07B9:  MOVLW  1D
07BA:  MOVWF  69
07BB:  BCF    03.6
07BC:  CALL   566
....................          //turnled(); 
....................          } 
....................        else{ 
07BD:  GOTO   7DA
07BE:  BSF    03.6
....................        sendsms(numberphone,saicuphap); 
07BF:  CLRF   79
07C0:  MOVLW  0C
07C1:  MOVWF  78
07C2:  MOVLW  1D
07C3:  MOVWF  04
07C4:  BSF    03.7
07C5:  MOVF   79,W
07C6:  BCF    03.6
07C7:  CALL   087
07C8:  MOVWF  00
07C9:  INCF   79,F
07CA:  INCF   04,F
07CB:  DECFSZ 78,F
07CC:  GOTO   7CE
07CD:  GOTO   7D0
07CE:  BSF    03.6
07CF:  GOTO   7C5
07D0:  BSF    03.6
07D1:  CLRF   68
07D2:  MOVLW  60
07D3:  MOVWF  67
07D4:  MOVLW  01
07D5:  MOVWF  6A
07D6:  MOVLW  1D
07D7:  MOVWF  69
07D8:  BCF    03.6
07D9:  CALL   566
....................       }  
....................       return 0; 
07DA:  MOVLW  00
07DB:  MOVWF  78
07DC:  BSF    03.6
.................... } 
07DD:  BCF    03.6
07DE:  BCF    0A.3
07DF:  BSF    0A.4
07E0:  GOTO   0B6 (RETURN)
....................  
.................... int admin2(){ 
*
0CE6:  BSF    03.6
0CE7:  CLRF   1C
.................... int t=0; 
....................    if(strstr(smstext,doiad)!=0){ 
0CE8:  MOVLW  64
0CE9:  MOVWF  1D
0CEA:  MOVLW  6F
0CEB:  MOVWF  1E
0CEC:  MOVLW  69
0CED:  MOVWF  1F
0CEE:  MOVLW  61
0CEF:  MOVWF  20
0CF0:  MOVLW  64
0CF1:  MOVWF  21
0CF2:  CLRF   22
0CF3:  CLRF   35
0CF4:  MOVLW  A0
0CF5:  MOVWF  34
0CF6:  MOVLW  01
0CF7:  MOVWF  37
0CF8:  MOVLW  1D
0CF9:  MOVWF  36
0CFA:  BCF    0A.3
0CFB:  BCF    03.6
0CFC:  CALL   516
0CFD:  BSF    0A.3
0CFE:  MOVF   79,W
0CFF:  BSF    03.6
0D00:  MOVWF  35
0D01:  MOVF   78,W
0D02:  MOVWF  34
0D03:  MOVF   34,F
0D04:  BTFSS  03.2
0D05:  GOTO   509
0D06:  MOVF   35,F
0D07:  BTFSC  03.2
0D08:  GOTO   5A9
....................        p_char1=gsmchr(smstext,smssize,'d',2);//lay so dien thoai trong tin nhan  
0D09:  CLRF   66
0D0A:  MOVLW  A0
0D0B:  MOVWF  65
0D0C:  MOVLW  1A
0D0D:  MOVWF  67
0D0E:  MOVLW  64
0D0F:  MOVWF  68
0D10:  MOVLW  02
0D11:  MOVWF  69
0D12:  BCF    0A.3
0D13:  BCF    03.6
0D14:  CALL   3FF
0D15:  BSF    0A.3
0D16:  MOVF   78,W
0D17:  MOVWF  75
....................        p_char2=gsmchr(smstext,smssize,';',1);           
0D18:  BSF    03.6
0D19:  CLRF   66
0D1A:  MOVLW  A0
0D1B:  MOVWF  65
0D1C:  MOVLW  1A
0D1D:  MOVWF  67
0D1E:  MOVLW  3B
0D1F:  MOVWF  68
0D20:  MOVLW  01
0D21:  MOVWF  69
0D22:  BCF    0A.3
0D23:  BCF    03.6
0D24:  CALL   3FF
0D25:  BSF    0A.3
0D26:  MOVF   78,W
0D27:  MOVWF  76
....................        if(p_char2>p_char1){ 
0D28:  MOVF   76,W
0D29:  SUBWF  75,W
0D2A:  BTFSC  03.0
0D2B:  GOTO   5A7
....................        for(t=0;t<6;t++)       
0D2C:  BSF    03.6
0D2D:  CLRF   1C
0D2E:  MOVF   1C,W
0D2F:  SUBLW  05
0D30:  BTFSS  03.0
0D31:  GOTO   544
....................          if(smstext[p_char1+t+1]!=mk[t])break; 
0D32:  MOVF   1C,W
0D33:  ADDWF  75,W
0D34:  ADDLW  01
0D35:  ADDLW  A0
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  MOVF   00,W
0D39:  MOVWF  32
0D3A:  MOVLW  E0
0D3B:  ADDWF  1C,W
0D3C:  MOVWF  04
0D3D:  BCF    03.7
0D3E:  MOVF   00,W
0D3F:  SUBWF  32,W
0D40:  BTFSS  03.2
0D41:  GOTO   544
0D42:  INCF   1C,F
0D43:  GOTO   52E
....................        if(t==6){ 
0D44:  MOVF   1C,W
0D45:  SUBLW  06
0D46:  BTFSS  03.2
0D47:  GOTO   588
....................          eeprom_read_string(0x10,numtem,15); 
0D48:  MOVLW  10
0D49:  MOVWF  5D
0D4A:  CLRF   5F
0D4B:  MOVLW  D0
0D4C:  MOVWF  5E
0D4D:  MOVLW  0F
0D4E:  MOVWF  60
0D4F:  BCF    0A.3
0D50:  BCF    03.6
0D51:  CALL   41D
0D52:  BSF    0A.3
....................          eeprom_write_string(0x10,numtem1); 
0D53:  MOVLW  10
0D54:  BSF    03.6
0D55:  MOVWF  65
0D56:  CLRF   67
0D57:  MOVLW  C0
0D58:  MOVWF  66
0D59:  BCF    0A.3
0D5A:  BCF    03.6
0D5B:  CALL   59E
0D5C:  BSF    0A.3
....................          eeprom_write_string(admin*16,numtem);  
0D5D:  SWAPF  7C,W
0D5E:  BSF    03.6
0D5F:  MOVWF  32
0D60:  MOVLW  F0
0D61:  ANDWF  32,F
0D62:  MOVF   32,W
0D63:  MOVWF  65
0D64:  CLRF   67
0D65:  MOVLW  D0
0D66:  MOVWF  66
0D67:  BCF    0A.3
0D68:  BCF    03.6
0D69:  CALL   59E
0D6A:  BSF    0A.3
....................          sendsms(numberphone,msg8);//doi admin thanh cong  
0D6B:  CLRF   79
0D6C:  MOVLW  15
0D6D:  MOVWF  78
0D6E:  MOVLW  1D
0D6F:  MOVWF  04
0D70:  BSF    03.7
0D71:  MOVF   79,W
0D72:  BCF    0A.3
0D73:  CALL   1B1
0D74:  BSF    0A.3
0D75:  MOVWF  00
0D76:  INCF   79,F
0D77:  INCF   04,F
0D78:  DECFSZ 78,F
0D79:  GOTO   571
0D7A:  BSF    03.6
0D7B:  CLRF   68
0D7C:  MOVLW  60
0D7D:  MOVWF  67
0D7E:  MOVLW  01
0D7F:  MOVWF  6A
0D80:  MOVLW  1D
0D81:  MOVWF  69
0D82:  BCF    0A.3
0D83:  BCF    03.6
0D84:  CALL   566
0D85:  BSF    0A.3
....................         }else { 
0D86:  GOTO   5A7
0D87:  BSF    03.6
....................          sendsms(numberphone,msg6);//sai mat khau       
0D88:  CLRF   79
0D89:  MOVLW  0D
0D8A:  MOVWF  78
0D8B:  MOVLW  1D
0D8C:  MOVWF  04
0D8D:  BSF    03.7
0D8E:  MOVF   79,W
0D8F:  BCF    0A.3
0D90:  BCF    03.6
0D91:  CALL   184
0D92:  BSF    0A.3
0D93:  MOVWF  00
0D94:  INCF   79,F
0D95:  INCF   04,F
0D96:  DECFSZ 78,F
0D97:  GOTO   599
0D98:  GOTO   59B
0D99:  BSF    03.6
0D9A:  GOTO   58E
0D9B:  BSF    03.6
0D9C:  CLRF   68
0D9D:  MOVLW  60
0D9E:  MOVWF  67
0D9F:  MOVLW  01
0DA0:  MOVWF  6A
0DA1:  MOVLW  1D
0DA2:  MOVWF  69
0DA3:  BCF    0A.3
0DA4:  BCF    03.6
0DA5:  CALL   566
0DA6:  BSF    0A.3
....................         } 
....................        }           
....................      } 
....................      else if(strstr(smstext, kttk1)!=0){ 
0DA7:  GOTO   610
0DA8:  BSF    03.6
0DA9:  MOVLW  6B
0DAA:  MOVWF  1D
0DAB:  MOVLW  74
0DAC:  MOVWF  1E
0DAD:  MOVWF  1F
0DAE:  MOVLW  6B
0DAF:  MOVWF  20
0DB0:  MOVLW  31
0DB1:  MOVWF  21
0DB2:  CLRF   22
0DB3:  CLRF   35
0DB4:  MOVLW  A0
0DB5:  MOVWF  34
0DB6:  MOVLW  01
0DB7:  MOVWF  37
0DB8:  MOVLW  1D
0DB9:  MOVWF  36
0DBA:  BCF    0A.3
0DBB:  BCF    03.6
0DBC:  CALL   516
0DBD:  BSF    0A.3
0DBE:  MOVF   79,W
0DBF:  BSF    03.6
0DC0:  MOVWF  35
0DC1:  MOVF   78,W
0DC2:  MOVWF  34
0DC3:  MOVF   34,F
0DC4:  BTFSS  03.2
0DC5:  GOTO   5C9
0DC6:  MOVF   35,F
0DC7:  BTFSC  03.2
0DC8:  GOTO   5CD
....................        return 1;        
0DC9:  MOVLW  01
0DCA:  MOVWF  78
0DCB:  GOTO   613
....................        } 
....................       else if(strstr(smstext, kttk2)!=0){                  
0DCC:  GOTO   611
0DCD:  MOVLW  6B
0DCE:  MOVWF  1D
0DCF:  MOVLW  74
0DD0:  MOVWF  1E
0DD1:  MOVWF  1F
0DD2:  MOVLW  6B
0DD3:  MOVWF  20
0DD4:  MOVLW  32
0DD5:  MOVWF  21
0DD6:  CLRF   22
0DD7:  CLRF   35
0DD8:  MOVLW  A0
0DD9:  MOVWF  34
0DDA:  MOVLW  01
0DDB:  MOVWF  37
0DDC:  MOVLW  1D
0DDD:  MOVWF  36
0DDE:  BCF    0A.3
0DDF:  BCF    03.6
0DE0:  CALL   516
0DE1:  BSF    0A.3
0DE2:  MOVF   79,W
0DE3:  BSF    03.6
0DE4:  MOVWF  35
0DE5:  MOVF   78,W
0DE6:  MOVWF  34
0DE7:  MOVF   34,F
0DE8:  BTFSS  03.2
0DE9:  GOTO   5ED
0DEA:  MOVF   35,F
0DEB:  BTFSC  03.2
0DEC:  GOTO   5F1
....................          return 2;        
0DED:  MOVLW  02
0DEE:  MOVWF  78
0DEF:  GOTO   613
....................       } 
....................      else{ 
0DF0:  GOTO   611
....................        sendsms(numberphone,saicuphap); 
0DF1:  CLRF   79
0DF2:  MOVLW  0C
0DF3:  MOVWF  78
0DF4:  MOVLW  1D
0DF5:  MOVWF  04
0DF6:  BSF    03.7
0DF7:  MOVF   79,W
0DF8:  BCF    0A.3
0DF9:  BCF    03.6
0DFA:  CALL   087
0DFB:  BSF    0A.3
0DFC:  MOVWF  00
0DFD:  INCF   79,F
0DFE:  INCF   04,F
0DFF:  DECFSZ 78,F
0E00:  GOTO   602
0E01:  GOTO   604
0E02:  BSF    03.6
0E03:  GOTO   5F7
0E04:  BSF    03.6
0E05:  CLRF   68
0E06:  MOVLW  60
0E07:  MOVWF  67
0E08:  MOVLW  01
0E09:  MOVWF  6A
0E0A:  MOVLW  1D
0E0B:  MOVWF  69
0E0C:  BCF    0A.3
0E0D:  BCF    03.6
0E0E:  CALL   566
0E0F:  BSF    0A.3
0E10:  BSF    03.6
....................        } 
....................     return 0; 
0E11:  MOVLW  00
0E12:  MOVWF  78
.................... } 
0E13:  BCF    03.6
0E14:  BCF    0A.3
0E15:  BSF    0A.4
0E16:  GOTO   0EF (RETURN)
....................  
.................... void admin0(){ 
....................       eeprom_read_string(0x10,numtem,15);  
0E17:  MOVLW  10
0E18:  BSF    03.6
0E19:  MOVWF  5D
0E1A:  CLRF   5F
0E1B:  MOVLW  D0
0E1C:  MOVWF  5E
0E1D:  MOVLW  0F
0E1E:  MOVWF  60
0E1F:  BCF    0A.3
0E20:  BCF    03.6
0E21:  CALL   41D
0E22:  BSF    0A.3
....................        for(i=0;i<15;i++) 
0E23:  CLRF   71
0E24:  MOVF   71,W
0E25:  SUBLW  0E
0E26:  BTFSS  03.0
0E27:  GOTO   637
....................        if(numtem[i]==' ')numtem[i]=0; 
0E28:  MOVLW  D0
0E29:  ADDWF  71,W
0E2A:  MOVWF  04
0E2B:  BCF    03.7
0E2C:  MOVF   00,W
0E2D:  SUBLW  20
0E2E:  BTFSS  03.2
0E2F:  GOTO   635
0E30:  MOVLW  D0
0E31:  ADDWF  71,W
0E32:  MOVWF  04
0E33:  BCF    03.7
0E34:  CLRF   00
0E35:  INCF   71,F
0E36:  GOTO   624
....................        strcpy( RxBuf, numberphone); 
0E37:  BSF    03.6
0E38:  CLRF   1F
0E39:  MOVLW  60
0E3A:  MOVWF  1E
0E3B:  CLRF   1D
0E3C:  MOVLW  29
0E3D:  MOVWF  1C
0E3E:  MOVF   1E,W
0E3F:  MOVWF  04
0E40:  BCF    03.7
0E41:  BTFSC  1F.0
0E42:  BSF    03.7
0E43:  MOVF   00,W
0E44:  MOVWF  20
0E45:  MOVF   1C,W
0E46:  MOVWF  04
0E47:  BCF    03.7
0E48:  BTFSC  1D.0
0E49:  BSF    03.7
0E4A:  MOVF   20,W
0E4B:  MOVWF  00
0E4C:  MOVF   00,F
0E4D:  BTFSC  03.2
0E4E:  GOTO   652
0E4F:  INCF   1C,F
0E50:  INCF   1E,F
0E51:  GOTO   63E
....................        strcat( RxBuf, smstext); 
0E52:  CLRF   1D
0E53:  MOVLW  29
0E54:  MOVWF  1C
0E55:  CLRF   1F
0E56:  MOVLW  A0
0E57:  MOVWF  1E
....................        sendsms(numtem,RxBuf);//gui lai noi dung tin nhan so la 
*
0E93:  CLRF   68
0E94:  MOVLW  D0
0E95:  MOVWF  67
0E96:  CLRF   6A
0E97:  MOVLW  29
0E98:  MOVWF  69
0E99:  BCF    0A.3
0E9A:  BCF    03.6
0E9B:  CALL   566
0E9C:  BSF    0A.3
.................... } 
0E9D:  BCF    0A.3
0E9E:  BSF    0A.4
0E9F:  GOTO   10D (RETURN)
.................... //ham doc noi dung tin nhan co lenh bat led hay khong, neu co thi bat led 
.................... int readsms(){ 
*
0446:  BSF    03.6
0447:  CLRF   1C
.................... int t=0;        
....................        p_char1=gsmchr(RxBuf,RXBUFSIZE,'"',1);//lay so dt nt den 
0448:  CLRF   66
0449:  MOVLW  29
044A:  MOVWF  65
044B:  MOVLW  37
044C:  MOVWF  67
044D:  MOVLW  22
044E:  MOVWF  68
044F:  MOVLW  01
0450:  MOVWF  69
0451:  BCF    03.6
0452:  CALL   3FF
0453:  MOVF   78,W
0454:  MOVWF  75
....................        p_char2=gsmchr(RxBuf,RXBUFSIZE,'"',2);    
0455:  BSF    03.6
0456:  CLRF   66
0457:  MOVLW  29
0458:  MOVWF  65
0459:  MOVLW  37
045A:  MOVWF  67
045B:  MOVLW  22
045C:  MOVWF  68
045D:  MOVLW  02
045E:  MOVWF  69
045F:  BCF    03.6
0460:  CALL   3FF
0461:  MOVF   78,W
0462:  MOVWF  76
....................        if(p_char1<p_char2){     
0463:  MOVF   76,W
0464:  SUBWF  75,W
0465:  BTFSC  03.0
0466:  GOTO   50F
....................           for(i=p_char1+1;i<p_char2;i++){ 
0467:  MOVLW  01
0468:  ADDWF  75,W
0469:  MOVWF  71
046A:  MOVF   76,W
046B:  SUBWF  71,W
046C:  BTFSC  03.0
046D:  GOTO   48B
....................             numberphone[i-p_char1-1]=RxBuf[i]; 
046E:  MOVF   75,W
046F:  SUBWF  71,W
0470:  ADDLW  FF
0471:  ADDLW  60
0472:  MOVWF  78
0473:  CLRF   7A
0474:  BTFSC  03.0
0475:  INCF   7A,F
0476:  MOVF   78,W
0477:  BSF    03.6
0478:  MOVWF  1D
0479:  MOVF   7A,W
047A:  MOVWF  1E
047B:  MOVLW  29
047C:  ADDWF  71,W
047D:  MOVWF  04
047E:  BCF    03.7
047F:  MOVF   00,W
0480:  MOVWF  1F
0481:  MOVF   1D,W
0482:  MOVWF  04
0483:  BCF    03.7
0484:  BTFSC  1E.0
0485:  BSF    03.7
0486:  MOVF   1F,W
0487:  MOVWF  00
....................           }    
0488:  INCF   71,F
0489:  BCF    03.6
048A:  GOTO   46A
....................           //numberphone[p_char2-p_char1-1]=' '; 
....................  
....................           for(i=3;i<16;i++){ 
048B:  MOVLW  03
048C:  MOVWF  71
048D:  MOVF   71,W
048E:  SUBLW  0F
048F:  BTFSS  03.0
0490:  GOTO   4BA
....................             numtem1[i-2]=numberphone[i]; 
0491:  MOVLW  02
0492:  SUBWF  71,W
0493:  ADDLW  C0
0494:  MOVWF  78
0495:  CLRF   7A
0496:  BTFSC  03.0
0497:  INCF   7A,F
0498:  MOVF   78,W
0499:  BSF    03.6
049A:  MOVWF  1D
049B:  MOVF   7A,W
049C:  MOVWF  1E
049D:  MOVLW  60
049E:  ADDWF  71,W
049F:  MOVWF  04
04A0:  BCF    03.7
04A1:  MOVF   00,W
04A2:  MOVWF  1F
04A3:  MOVF   1D,W
04A4:  MOVWF  04
04A5:  BCF    03.7
04A6:  BTFSC  1E.0
04A7:  BSF    03.7
04A8:  MOVF   1F,W
04A9:  MOVWF  00
....................             if(numberphone[i]==' '){ 
04AA:  MOVLW  60
04AB:  ADDWF  71,W
04AC:  MOVWF  04
04AD:  BCF    03.7
04AE:  MOVF   00,W
04AF:  SUBLW  20
04B0:  BTFSS  03.2
04B1:  GOTO   4B7
....................             numberphone[i]=0; 
04B2:  MOVLW  60
04B3:  ADDWF  71,W
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  CLRF   00
....................             } 
....................           }//printf("%s", numberphone);           
04B7:  INCF   71,F
04B8:  BCF    03.6
04B9:  GOTO   48D
....................          numtem1[0]='0';                  
04BA:  MOVLW  30
04BB:  BSF    03.5
04BC:  MOVWF  40
....................         admin=0;        
04BD:  CLRF   7C
....................         eeprom_read_string(0x00,numfull,5);//doc trang thai danh sach sdt 
04BE:  BCF    03.5
04BF:  BSF    03.6
04C0:  CLRF   5D
04C1:  CLRF   5F
04C2:  MOVLW  BA
04C3:  MOVWF  5E
04C4:  MOVLW  05
04C5:  MOVWF  60
04C6:  BCF    03.6
04C7:  CALL   41D
....................         
....................         for(i=0;i<5;i++) 
04C8:  CLRF   71
04C9:  MOVF   71,W
04CA:  SUBLW  04
04CB:  BTFSS  03.0
04CC:  GOTO   50F
....................          if(numfull[i]=='1'){ //so sanh vs sdt trong danh sach 
04CD:  MOVLW  BA
04CE:  ADDWF  71,W
04CF:  MOVWF  04
04D0:  BCF    03.7
04D1:  MOVF   00,W
04D2:  SUBLW  31
04D3:  BTFSS  03.2
04D4:  GOTO   50D
....................            eeprom_read_string(16*(i+1),numtem,15);            
04D5:  MOVLW  01
04D6:  ADDWF  71,W
04D7:  MOVWF  77
04D8:  SWAPF  77,W
04D9:  BSF    03.6
04DA:  MOVWF  1D
04DB:  MOVLW  F0
04DC:  ANDWF  1D,F
04DD:  MOVF   1D,W
04DE:  MOVWF  5D
04DF:  CLRF   5F
04E0:  MOVLW  D0
04E1:  MOVWF  5E
04E2:  MOVLW  0F
04E3:  MOVWF  60
04E4:  BCF    03.6
04E5:  CALL   41D
....................             for(t=0;t<15;t++){ 
04E6:  BSF    03.6
04E7:  CLRF   1C
04E8:  MOVF   1C,W
04E9:  SUBLW  0E
04EA:  BTFSS  03.0
04EB:  GOTO   50C
....................             if(numtem1[t]==numtem[t]){           
04EC:  MOVLW  C0
04ED:  ADDWF  1C,W
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  MOVF   00,W
04F1:  MOVWF  1D
04F2:  MOVLW  D0
04F3:  ADDWF  1C,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  MOVF   00,W
04F7:  SUBWF  1D,W
04F8:  BTFSS  03.2
04F9:  GOTO   509
....................             if(numtem[t]==' '){ 
04FA:  MOVLW  D0
04FB:  ADDWF  1C,W
04FC:  MOVWF  04
04FD:  BCF    03.7
04FE:  MOVF   00,W
04FF:  SUBLW  20
0500:  BTFSS  03.2
0501:  GOTO   508
....................                admin=i+1;                
0502:  MOVLW  01
0503:  ADDWF  71,W
0504:  MOVWF  7C
....................                return 1;; 
0505:  MOVLW  01
0506:  MOVWF  78
0507:  GOTO   512
....................             }                         
....................           }else break; 
0508:  GOTO   50A
0509:  GOTO   50C
....................          }  
050A:  INCF   1C,F
050B:  GOTO   4E8
050C:  BCF    03.6
....................        }//printf("%d", admin);               
050D:  INCF   71,F
050E:  GOTO   4C9
....................      } 
....................    return 0; 
050F:  MOVLW  00
0510:  MOVWF  78
0511:  BSF    03.6
.................... } 
0512:  BCF    03.6
0513:  BCF    0A.3
0514:  BSF    0A.4
0515:  GOTO   0AE (RETURN)
....................  
.................... //ham kiem tra cuoc goi den, neu co thi bat led trong 5s 
.................... int checkcall(){ 
.................... int t;  
....................    sendCommand(atclcc); 
*
0EA0:  CLRF   79
0EA1:  MOVLW  08
0EA2:  MOVWF  78
0EA3:  MOVLW  1D
0EA4:  MOVWF  04
0EA5:  BSF    03.7
0EA6:  MOVF   79,W
0EA7:  BCF    0A.3
0EA8:  CALL   1D5
0EA9:  BSF    0A.3
0EAA:  MOVWF  00
0EAB:  INCF   79,F
0EAC:  INCF   04,F
0EAD:  DECFSZ 78,F
0EAE:  GOTO   6A6
0EAF:  MOVLW  01
0EB0:  BSF    03.6
0EB1:  MOVWF  32
0EB2:  MOVLW  1D
0EB3:  MOVWF  31
0EB4:  BCF    0A.3
0EB5:  BCF    03.6
0EB6:  CALL   330
0EB7:  BSF    0A.3
....................    if(IsStringReceived(clcc)){ 
0EB8:  CLRF   79
0EB9:  MOVLW  11
0EBA:  MOVWF  78
0EBB:  MOVLW  1D
0EBC:  MOVWF  04
0EBD:  BSF    03.7
0EBE:  MOVF   79,W
0EBF:  BCF    0A.3
0EC0:  CALL   1E1
0EC1:  BSF    0A.3
0EC2:  MOVWF  00
0EC3:  INCF   79,F
0EC4:  INCF   04,F
0EC5:  DECFSZ 78,F
0EC6:  GOTO   6BE
0EC7:  MOVLW  01
0EC8:  BSF    03.6
0EC9:  MOVWF  32
0ECA:  MOVLW  1D
0ECB:  MOVWF  31
0ECC:  BCF    03.6
0ECD:  CALL   332
0ECE:  MOVF   78,F
0ECF:  BTFSC  03.2
0ED0:  GOTO   787
....................     p_char1=gsmchr(RxBuf,RXBUFSIZE,'"',1); //lay sdt goi den 
0ED1:  BSF    03.6
0ED2:  CLRF   66
0ED3:  MOVLW  29
0ED4:  MOVWF  65
0ED5:  MOVLW  37
0ED6:  MOVWF  67
0ED7:  MOVLW  22
0ED8:  MOVWF  68
0ED9:  MOVLW  01
0EDA:  MOVWF  69
0EDB:  BCF    0A.3
0EDC:  BCF    03.6
0EDD:  CALL   3FF
0EDE:  BSF    0A.3
0EDF:  MOVF   78,W
0EE0:  MOVWF  75
....................     p_char2=gsmchr(RxBuf,RXBUFSIZE,'"',2);    
0EE1:  BSF    03.6
0EE2:  CLRF   66
0EE3:  MOVLW  29
0EE4:  MOVWF  65
0EE5:  MOVLW  37
0EE6:  MOVWF  67
0EE7:  MOVLW  22
0EE8:  MOVWF  68
0EE9:  MOVLW  02
0EEA:  MOVWF  69
0EEB:  BCF    0A.3
0EEC:  BCF    03.6
0EED:  CALL   3FF
0EEE:  BSF    0A.3
0EEF:  MOVF   78,W
0EF0:  MOVWF  76
....................     if(p_char1<p_char2){     
0EF1:  MOVF   76,W
0EF2:  SUBWF  75,W
0EF3:  BTFSC  03.0
0EF4:  GOTO   787
....................     for(i=p_char1+1;i<p_char2;i++){ 
0EF5:  MOVLW  01
0EF6:  ADDWF  75,W
0EF7:  MOVWF  71
0EF8:  MOVF   76,W
0EF9:  SUBWF  71,W
0EFA:  BTFSC  03.0
0EFB:  GOTO   715
....................     numberphone[i-p_char1-1]=RxBuf[i]; 
0EFC:  MOVF   75,W
0EFD:  SUBWF  71,W
0EFE:  ADDLW  FF
0EFF:  ADDLW  60
0F00:  BSF    03.6
0F01:  MOVWF  2E
0F02:  CLRF   2F
0F03:  BTFSC  03.0
0F04:  INCF   2F,F
0F05:  MOVLW  29
0F06:  ADDWF  71,W
0F07:  MOVWF  04
0F08:  BCF    03.7
0F09:  MOVF   00,W
0F0A:  MOVWF  30
0F0B:  MOVF   2E,W
0F0C:  MOVWF  04
0F0D:  BCF    03.7
0F0E:  BTFSC  2F.0
0F0F:  BSF    03.7
0F10:  MOVF   30,W
0F11:  MOVWF  00
....................     } 
0F12:  INCF   71,F
0F13:  BCF    03.6
0F14:  GOTO   6F8
....................     //numberphone(p_char2-p_char1-1)=' '; 
....................       eeprom_read_string(0x00,numfull,5);//doc trang thai danh sach sdt 
0F15:  BSF    03.6
0F16:  CLRF   5D
0F17:  CLRF   5F
0F18:  MOVLW  BA
0F19:  MOVWF  5E
0F1A:  MOVLW  05
0F1B:  MOVWF  60
0F1C:  BCF    0A.3
0F1D:  BCF    03.6
0F1E:  CALL   41D
0F1F:  BSF    0A.3
....................       for(i=0;i<5;i++) 
0F20:  CLRF   71
0F21:  MOVF   71,W
0F22:  SUBLW  04
0F23:  BTFSS  03.0
0F24:  GOTO   766
....................       if(numfull[i]=='1'){ //doc trang thai danh sach 
0F25:  MOVLW  BA
0F26:  ADDWF  71,W
0F27:  MOVWF  04
0F28:  BCF    03.7
0F29:  MOVF   00,W
0F2A:  SUBLW  31
0F2B:  BTFSS  03.2
0F2C:  GOTO   764
....................       eeprom_read_string(16*(i+1),numtem,15);//doc sdt trong danh sach   
0F2D:  MOVLW  01
0F2E:  ADDWF  71,W
0F2F:  MOVWF  77
0F30:  SWAPF  77,W
0F31:  BSF    03.6
0F32:  MOVWF  2E
0F33:  MOVLW  F0
0F34:  ANDWF  2E,F
0F35:  MOVF   2E,W
0F36:  MOVWF  5D
0F37:  CLRF   5F
0F38:  MOVLW  D0
0F39:  MOVWF  5E
0F3A:  MOVLW  0F
0F3B:  MOVWF  60
0F3C:  BCF    0A.3
0F3D:  BCF    03.6
0F3E:  CALL   41D
0F3F:  BSF    0A.3
....................       for(t=0;t<15;t++){ 
0F40:  BSF    03.6
0F41:  CLRF   1C
0F42:  MOVF   1C,W
0F43:  SUBLW  0E
0F44:  BTFSS  03.0
0F45:  GOTO   763
....................       if(numberphone[t]==numtem[t]){ 
0F46:  MOVLW  60
0F47:  ADDWF  1C,W
0F48:  MOVWF  04
0F49:  BCF    03.7
0F4A:  MOVF   00,W
0F4B:  MOVWF  2E
0F4C:  MOVLW  D0
0F4D:  ADDWF  1C,W
0F4E:  MOVWF  04
0F4F:  BCF    03.7
0F50:  MOVF   00,W
0F51:  SUBWF  2E,W
0F52:  BTFSS  03.2
0F53:  GOTO   760
....................       if(numtem[t]==' '){   
0F54:  MOVLW  D0
0F55:  ADDWF  1C,W
0F56:  MOVWF  04
0F57:  BCF    03.7
0F58:  MOVF   00,W
0F59:  SUBLW  20
0F5A:  BTFSS  03.2
0F5B:  GOTO   75F
....................         
....................        return 1; 
0F5C:  MOVLW  01
0F5D:  MOVWF  78
0F5E:  GOTO   78A
....................       } 
....................       }else break; 
0F5F:  GOTO   761
0F60:  GOTO   763
....................       }      
0F61:  INCF   1C,F
0F62:  GOTO   742
0F63:  BCF    03.6
....................       } 
0F64:  INCF   71,F
0F65:  GOTO   721
....................       delay_ms(800); 
0F66:  MOVLW  04
0F67:  BSF    03.6
0F68:  MOVWF  2E
0F69:  MOVLW  C8
0F6A:  MOVWF  6C
0F6B:  BCF    0A.3
0F6C:  BCF    03.6
0F6D:  CALL   2C2
0F6E:  BSF    0A.3
0F6F:  BSF    03.6
0F70:  DECFSZ 2E,F
0F71:  GOTO   769
....................       printf("ATH\r\n");    
0F72:  MOVLW  1D
0F73:  MOVWF  0D
0F74:  MOVLW  02
0F75:  MOVWF  0F
0F76:  BCF    0A.3
0F77:  BCF    03.6
0F78:  CALL   2D6
0F79:  BSF    0A.3
....................       delay_ms(800);        
0F7A:  MOVLW  04
0F7B:  BSF    03.6
0F7C:  MOVWF  2E
0F7D:  MOVLW  C8
0F7E:  MOVWF  6C
0F7F:  BCF    0A.3
0F80:  BCF    03.6
0F81:  CALL   2C2
0F82:  BSF    0A.3
0F83:  BSF    03.6
0F84:  DECFSZ 2E,F
0F85:  GOTO   77D
0F86:  BCF    03.6
....................        
....................     } 
....................    } 
....................   return 0; 
0F87:  MOVLW  00
0F88:  MOVWF  78
0F89:  BSF    03.6
.................... } 
0F8A:  BCF    03.6
0F8B:  BCF    0A.3
0F8C:  BSF    0A.4
0F8D:  GOTO   151 (RETURN)
....................  
.................... void echo(){ 
*
0223:  DATA 00,00
....................    printf("ATE0\r\n"); 
*
03EA:  MOVLW  20
03EB:  BSF    03.6
03EC:  MOVWF  0D
03ED:  MOVLW  02
03EE:  MOVWF  0F
03EF:  BCF    03.6
03F0:  CALL   2D6
....................    delay_ms(800);// 
03F1:  MOVLW  04
03F2:  BSF    03.6
03F3:  MOVWF  1C
03F4:  MOVLW  C8
03F5:  MOVWF  6C
03F6:  BCF    03.6
03F7:  CALL   2C2
03F8:  BSF    03.6
03F9:  DECFSZ 1C,F
03FA:  GOTO   3F4
.................... } 
03FB:  BCF    03.6
03FC:  BCF    0A.3
03FD:  BSF    0A.4
03FE:  GOTO   06D (RETURN)
....................  
.................... //ham set che do text mode cho sim900 
.................... void GSM_sel_mess_mode(int mode) 
.................... { 
*
0227:  DATA 00,00
....................    if(mode>0) //text mode 
*
0359:  BSF    03.6
035A:  MOVF   1C,F
035B:  BTFSC  03.2
035C:  GOTO   39F
....................       { 
.................... //!        delay_ms(800);          
.................... //!        printf("AT+CMEE=0\r\n"); 
.................... //!        delay_ms(800);          
.................... //!         printf("AT+CMGF=1\r\n"); 
.................... //!         delay_ms(800);    
.................... //!         printf("AT+CNMI=2,2,0,0,0\r\n"); 
.................... //!         delay_ms(800); 
....................          sendCommand(cmgf); 
035D:  CLRF   79
035E:  MOVLW  0A
035F:  MOVWF  78
0360:  MOVLW  1D
0361:  MOVWF  04
0362:  BSF    03.7
0363:  MOVF   79,W
0364:  BCF    03.6
0365:  CALL   207
0366:  MOVWF  00
0367:  INCF   79,F
0368:  INCF   04,F
0369:  DECFSZ 78,F
036A:  GOTO   36C
036B:  GOTO   36E
036C:  BSF    03.6
036D:  GOTO   363
036E:  MOVLW  01
036F:  BSF    03.6
0370:  MOVWF  32
0371:  MOVLW  1D
0372:  MOVWF  31
0373:  BCF    03.6
0374:  CALL   330
....................          sendCommand(cmee); 
0375:  CLRF   79
0376:  MOVLW  0A
0377:  MOVWF  78
0378:  MOVLW  1D
0379:  MOVWF  04
037A:  BSF    03.7
037B:  MOVF   79,W
037C:  CALL   1F6
037D:  MOVWF  00
037E:  INCF   79,F
037F:  INCF   04,F
0380:  DECFSZ 78,F
0381:  GOTO   37B
0382:  MOVLW  01
0383:  BSF    03.6
0384:  MOVWF  32
0385:  MOVLW  1D
0386:  MOVWF  31
0387:  BCF    03.6
0388:  CALL   330
....................          sendCommand(cnmi); 
0389:  CLRF   79
038A:  MOVLW  12
038B:  MOVWF  78
038C:  MOVLW  1D
038D:  MOVWF  04
038E:  BSF    03.7
038F:  MOVF   79,W
0390:  CALL   09F
0391:  MOVWF  00
0392:  INCF   79,F
0393:  INCF   04,F
0394:  DECFSZ 78,F
0395:  GOTO   38F
0396:  MOVLW  01
0397:  BSF    03.6
0398:  MOVWF  32
0399:  MOVLW  1D
039A:  MOVWF  31
039B:  BCF    03.6
039C:  CALL   330
....................          //sendCommand(cpms); 
....................       } 
....................    else //PDU mode 
039D:  GOTO   3B9
039E:  BSF    03.6
....................       { 
....................          delay_ms(800); 
039F:  MOVLW  04
03A0:  MOVWF  2F
03A1:  MOVLW  C8
03A2:  MOVWF  6C
03A3:  BCF    03.6
03A4:  CALL   2C2
03A5:  BSF    03.6
03A6:  DECFSZ 2F,F
03A7:  GOTO   3A1
....................          //output_bit(Led1,1);     
....................          printf("AT&F\r\n"); 
03A8:  MOVLW  24
03A9:  MOVWF  0D
03AA:  MOVLW  02
03AB:  MOVWF  0F
03AC:  BCF    03.6
03AD:  CALL   2D6
....................          //putc(13);//enter CR 
....................          //Led1=!Led1; 
....................          delay_ms(1000);    
03AE:  MOVLW  04
03AF:  BSF    03.6
03B0:  MOVWF  2F
03B1:  MOVLW  FA
03B2:  MOVWF  6C
03B3:  BCF    03.6
03B4:  CALL   2C2
03B5:  BSF    03.6
03B6:  DECFSZ 2F,F
03B7:  GOTO   3B1
03B8:  BCF    03.6
....................       }  
.................... } 
03B9:  RETURN
.................... //ham khoi dong lcd 
.................... //!void GSM_start() 
.................... //!{ 
.................... //!   delay_ms(800); 
.................... //!   lcd_init();      
.................... //!   lcd_putc(init); 
.................... //!} 
.................... void GSM_sync() 
.................... { 
*
022D:  DATA 00,00
....................       delay_ms(2000);       
*
03BA:  MOVLW  08
03BB:  BSF    03.6
03BC:  MOVWF  1C
03BD:  MOVLW  FA
03BE:  MOVWF  6C
03BF:  BCF    03.6
03C0:  CALL   2C2
03C1:  BSF    03.6
03C2:  DECFSZ 1C,F
03C3:  GOTO   3BD
....................       //output_bit(Led1,1);            
....................       printf("AT\r\n"); 
03C4:  MOVLW  28
03C5:  MOVWF  0D
03C6:  MOVLW  02
03C7:  MOVWF  0F
03C8:  BCF    03.6
03C9:  CALL   2D6
....................       delay_ms(1000); 
03CA:  MOVLW  04
03CB:  BSF    03.6
03CC:  MOVWF  1C
03CD:  MOVLW  FA
03CE:  MOVWF  6C
03CF:  BCF    03.6
03D0:  CALL   2C2
03D1:  BSF    03.6
03D2:  DECFSZ 1C,F
03D3:  GOTO   3CD
....................        //output_bit(Led1,1);  
....................       printf("AT\r\n"); 
03D4:  MOVLW  2B
03D5:  MOVWF  0D
03D6:  MOVLW  02
03D7:  MOVWF  0F
03D8:  BCF    03.6
03D9:  CALL   2D6
....................       delay_ms(1000);   
03DA:  MOVLW  04
03DB:  BSF    03.6
03DC:  MOVWF  1C
03DD:  MOVLW  FA
03DE:  MOVWF  6C
03DF:  BCF    03.6
03E0:  CALL   2C2
03E1:  BSF    03.6
03E2:  DECFSZ 1C,F
03E3:  GOTO   3DD
....................       GSM_sel_mess_mode(0); 
03E4:  CLRF   1C
03E5:  BCF    03.6
03E6:  CALL   359
.................... } 
03E7:  BCF    0A.3
03E8:  BSF    0A.4
03E9:  GOTO   06A (RETURN)
....................  
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #rom 0x2100={0x31,0x30,0x30,0x30,0x30} 
.................... #rom 0x2110={0x30,0x31,0x36,0x36,0x33,0x39,0x31,0x35,0x33,0x30,0x38,0x20,0x20,0x20,0x20,0x20} 
.................... #rom 0x2160={0x31,0x31,0x31,0x31,0x31,0x31} 
.................... #define GSM_PW PIN_E2 
.................... #define GSM_SENSE PIN_E1 
.................... #define TEXTMODE 5 
.................... #define PDUMODE 0 
....................  
.................... int delay_100; 
.................... //********************************************************** 
.................... //      USART Interrupt service 
.................... //********************************************************** 
....................  
.................... #int_TIMER0 
.................... TIMER0_isr()  
.................... { 
....................    if(delay_100 < 40) 
*
022E:  BSF    03.5
022F:  MOVF   6B,W
0230:  SUBLW  27
0231:  BTFSS  03.0
0232:  GOTO   235
....................       delay_100++; 
0233:  INCF   6B,F
....................    else 
0234:  GOTO   23A
....................       { 
....................          delay_100=0; 
0235:  CLRF   6B
....................          Led2=!led2; 
0236:  MOVLW  08
0237:  BCF    03.5
0238:  XORWF  06,F
0239:  BSF    03.5
....................       } 
....................    
....................    return 0; 
023A:  MOVLW  00
023B:  MOVWF  78
.................... } 
....................  
023C:  BCF    03.5
023D:  BCF    0B.2
023E:  BCF    0A.3
023F:  BCF    0A.4
0240:  GOTO   021
.................... #INT_RDA 
.................... void rda() 
.................... { 
....................    UART_ISR(); 
.................... } 
....................  
*
02B2:  BCF    03.5
02B3:  BCF    0C.5
02B4:  BCF    0A.3
02B5:  BCF    0A.4
02B6:  GOTO   021
.................... void main() 
.................... {       
*
1000:  CLRF   04
1001:  BCF    03.7
1002:  MOVLW  1F
1003:  ANDWF  03,F
1004:  BSF    03.5
1005:  BSF    03.6
1006:  BSF    07.3
1007:  MOVLW  08
1008:  BCF    03.6
1009:  MOVWF  19
100A:  MOVLW  02
100B:  MOVWF  1A
100C:  MOVLW  A6
100D:  MOVWF  18
100E:  MOVLW  90
100F:  BCF    03.5
1010:  MOVWF  18
1011:  CLRF   70
1012:  CLRF   72
1013:  CLRF   73
1014:  CLRF   74
1015:  CLRF   7B
1016:  CLRF   7C
1017:  BSF    03.5
1018:  BSF    03.6
1019:  MOVF   09,W
101A:  ANDLW  C0
101B:  MOVWF  09
101C:  BCF    03.6
101D:  BCF    1F.4
101E:  BCF    1F.5
101F:  MOVLW  00
1020:  BSF    03.6
1021:  MOVWF  08
1022:  BCF    03.5
1023:  CLRF   07
1024:  CLRF   08
1025:  CLRF   09
....................    set_tris_b(0xf0); 
*
1029:  MOVLW  F0
102A:  BSF    03.5
102B:  MOVWF  06
....................    trisc1=0; 
102C:  BCF    07.1
....................    trisc2=0; 
102D:  BCF    07.2
....................    trisc3=0; 
102E:  BCF    07.3
....................    portb=0x0f; 
102F:  MOVLW  0F
1030:  BCF    03.5
1031:  MOVWF  06
....................    B1=0; 
1032:  BCF    06.1
....................    C1=0; 
1033:  BCF    07.1
....................    C2=1; 
1034:  BSF    07.2
....................    C3=1; 
1035:  BSF    07.3
....................     
....................    setup_adc_ports(NO_ANALOGS); 
1036:  BSF    03.5
1037:  BSF    03.6
1038:  MOVF   09,W
1039:  ANDLW  C0
103A:  MOVWF  09
103B:  BCF    03.6
103C:  BCF    1F.4
103D:  BCF    1F.5
103E:  MOVLW  00
103F:  BSF    03.6
1040:  MOVWF  08
....................    setup_adc(ADC_OFF); 
1041:  BCF    03.5
1042:  BCF    03.6
1043:  BCF    1F.0
....................    setup_spi(SPI_SS_DISABLED); 
1044:  BCF    14.5
1045:  MOVLW  01
1046:  MOVWF  14
1047:  MOVLW  00
1048:  BSF    03.5
1049:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); 
104A:  MOVF   01,W
104B:  ANDLW  C0
104C:  IORLW  07
104D:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
104E:  BCF    03.5
104F:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
1050:  MOVLW  00
1051:  MOVWF  78
1052:  MOVWF  12
1053:  MOVLW  00
1054:  BSF    03.5
1055:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
1056:  BCF    03.5
1057:  BSF    03.6
1058:  CLRF   07
1059:  CLRF   08
105A:  CLRF   09
....................    setup_vref(FALSE); 
105B:  BSF    03.5
105C:  BCF    03.6
105D:  CLRF   17
....................    enable_interrupts(INT_TIMER0); 
105E:  BCF    03.5
105F:  BSF    0B.5
....................    enable_interrupts(INT_RDA); 
1060:  BSF    03.5
1061:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
1062:  MOVLW  C0
1063:  BCF    03.5
1064:  IORWF  0B,F
....................    rcie=1; 
1065:  BSF    03.5
1066:  BSF    0C.5
....................  
....................    GSM_sync(); 
1067:  BCF    0A.4
1068:  BCF    03.5
1069:  GOTO   3BA
106A:  BSF    0A.4
....................    Echo(); 
106B:  BCF    0A.4
106C:  GOTO   3EA
106D:  BSF    0A.4
....................    GSM_sel_mess_mode(1); 
106E:  MOVLW  01
106F:  BSF    03.6
1070:  MOVWF  1C
1071:  BCF    0A.4
1072:  BCF    03.6
1073:  CALL   359
1074:  BSF    0A.4
....................    delay_ms(1000); 
1075:  MOVLW  04
1076:  BSF    03.5
1077:  MOVWF  6C
1078:  MOVLW  FA
1079:  BCF    03.5
107A:  BSF    03.6
107B:  MOVWF  6C
107C:  BCF    0A.4
107D:  BCF    03.6
107E:  CALL   2C2
107F:  BSF    0A.4
1080:  BSF    03.5
1081:  DECFSZ 6C,F
1082:  GOTO   078
....................       printf("AT+CMGDA=\"DEL READ\"\r\n"); 
1083:  MOVLW  B7
1084:  BCF    03.5
1085:  BSF    03.6
1086:  MOVWF  0D
1087:  MOVLW  02
1088:  MOVWF  0F
1089:  BCF    0A.4
108A:  BCF    03.6
108B:  CALL   2D6
108C:  BSF    0A.4
....................    delay_ms(800); 
108D:  MOVLW  04
108E:  BSF    03.5
108F:  MOVWF  6C
1090:  MOVLW  C8
1091:  BCF    03.5
1092:  BSF    03.6
1093:  MOVWF  6C
1094:  BCF    0A.4
1095:  BCF    03.6
1096:  CALL   2C2
1097:  BSF    0A.4
1098:  BSF    03.5
1099:  DECFSZ 6C,F
109A:  GOTO   090
....................     while(1){ 
....................     delay_ms(1000); 
109B:  MOVLW  04
109C:  MOVWF  6C
109D:  MOVLW  FA
109E:  BCF    03.5
109F:  BSF    03.6
10A0:  MOVWF  6C
10A1:  BCF    0A.4
10A2:  BCF    03.6
10A3:  CALL   2C2
10A4:  BSF    0A.4
10A5:  BSF    03.5
10A6:  DECFSZ 6C,F
10A7:  GOTO   09D
....................     if(calling!=1){ 
10A8:  DECFSZ 73,W
10A9:  GOTO   0AB
10AA:  GOTO   14B
....................     if(readsms())     
10AB:  BCF    0A.4
10AC:  BCF    03.5
10AD:  GOTO   446
10AE:  BSF    0A.4
10AF:  MOVF   78,F
10B0:  BTFSC  03.2
10B1:  GOTO   10F
....................     if(admin==1){ 
10B2:  DECFSZ 7C,W
10B3:  GOTO   0E8
....................       switch(admin1()){ 
10B4:  BCF    0A.4
10B5:  GOTO   5D4
10B6:  BSF    0A.4
10B7:  MOVF   78,W
10B8:  XORLW  01
10B9:  BTFSC  03.2
10BA:  GOTO   0C8
10BB:  XORLW  03
10BC:  BTFSC  03.2
10BD:  GOTO   0CE
10BE:  XORLW  01
10BF:  BTFSC  03.2
10C0:  GOTO   0D4
10C1:  XORLW  07
10C2:  BTFSC  03.2
10C3:  GOTO   0DA
10C4:  XORLW  01
10C5:  BTFSC  03.2
10C6:  GOTO   0E0
10C7:  GOTO   0E6
....................       case 1:themsdt(); 
10C8:  BCF    0A.4
10C9:  BSF    0A.3
10CA:  GOTO   000
10CB:  BSF    0A.4
10CC:  BCF    0A.3
....................       break; 
10CD:  GOTO   0E7
....................       case 2:xoasdt(); 
10CE:  BCF    0A.4
10CF:  BSF    0A.3
10D0:  GOTO   128
10D1:  BSF    0A.4
10D2:  BCF    0A.3
....................       break; 
10D3:  GOTO   0E7
....................       case 3:doimktk(); 
10D4:  BCF    0A.4
10D5:  BSF    0A.3
10D6:  GOTO   245
10D7:  BSF    0A.4
10D8:  BCF    0A.3
....................       break; 
10D9:  GOTO   0E7
....................       case 4:kttkchinh(); 
10DA:  BCF    0A.4
10DB:  BSF    0A.3
10DC:  CALL   360
10DD:  BSF    0A.4
10DE:  BCF    0A.3
....................       break; 
10DF:  GOTO   0E7
....................       case 5:kttkphu(); 
10E0:  BCF    0A.4
10E1:  BSF    0A.3
10E2:  CALL   423
10E3:  BSF    0A.4
10E4:  BCF    0A.3
....................       break; 
10E5:  GOTO   0E7
....................       default:break; 
10E6:  GOTO   0E7
....................       }       
....................     } 
....................     else if(admin>1){ 
10E7:  GOTO   10F
10E8:  MOVF   7C,W
10E9:  SUBLW  01
10EA:  BTFSC  03.0
10EB:  GOTO   107
....................       switch(admin2()){ 
10EC:  BCF    0A.4
10ED:  BSF    0A.3
10EE:  GOTO   4E6
10EF:  BSF    0A.4
10F0:  BCF    0A.3
10F1:  MOVF   78,W
10F2:  XORLW  01
10F3:  BTFSC  03.2
10F4:  GOTO   0F9
10F5:  XORLW  03
10F6:  BTFSC  03.2
10F7:  GOTO   0FF
10F8:  GOTO   105
....................       case 1:kttkchinh(); 
10F9:  BCF    0A.4
10FA:  BSF    0A.3
10FB:  CALL   360
10FC:  BSF    0A.4
10FD:  BCF    0A.3
....................       break; 
10FE:  GOTO   106
....................       case 2:kttkphu(); 
10FF:  BCF    0A.4
1100:  BSF    0A.3
1101:  CALL   423
1102:  BSF    0A.4
1103:  BCF    0A.3
....................       break; 
1104:  GOTO   106
....................       default:break; 
1105:  GOTO   106
....................       } 
....................     } 
....................     else if(admin==0) 
1106:  GOTO   10F
1107:  MOVF   7C,F
1108:  BTFSS  03.2
1109:  GOTO   10F
....................       admin0(); 
110A:  BCF    0A.4
110B:  BSF    0A.3
110C:  GOTO   617
110D:  BSF    0A.4
110E:  BCF    0A.3
....................     smsInit(); 
110F:  BCF    0A.4
1110:  GOTO   7E1
1111:  BSF    0A.4
....................     sendCommand(cmgd);  
1112:  CLRF   79
1113:  MOVLW  0A
1114:  MOVWF  78
1115:  MOVLW  10
1116:  MOVWF  04
1117:  BSF    03.7
1118:  MOVF   79,W
1119:  BCF    0A.4
111A:  CALL   0B5
111B:  BSF    0A.4
111C:  MOVWF  00
111D:  INCF   79,F
111E:  INCF   04,F
111F:  DECFSZ 78,F
1120:  GOTO   118
1121:  MOVLW  01
1122:  BSF    03.6
1123:  MOVWF  32
1124:  MOVLW  10
1125:  MOVWF  31
1126:  BCF    0A.4
1127:  BCF    03.6
1128:  CALL   330
1129:  BSF    0A.4
....................     calling=1; 
112A:  MOVLW  01
112B:  MOVWF  73
....................     numsms++; 
112C:  INCF   72,F
....................     if(numsms==10){ 
112D:  MOVF   72,W
112E:  SUBLW  0A
112F:  BTFSS  03.2
1130:  GOTO   149
....................     sendCommand(cmgdall); 
1131:  CLRF   79
1132:  MOVLW  0C
1133:  MOVWF  78
1134:  MOVLW  10
1135:  MOVWF  04
1136:  BSF    03.7
1137:  MOVF   79,W
1138:  BCF    0A.4
1139:  CALL   0C3
113A:  BSF    0A.4
113B:  MOVWF  00
113C:  INCF   79,F
113D:  INCF   04,F
113E:  DECFSZ 78,F
113F:  GOTO   137
1140:  MOVLW  01
1141:  BSF    03.6
1142:  MOVWF  32
1143:  MOVLW  10
1144:  MOVWF  31
1145:  BCF    0A.4
1146:  BCF    03.6
1147:  CALL   330
1148:  BSF    0A.4
....................     } 
....................     }else{ 
1149:  GOTO   15B
114A:  BSF    03.5
....................     if(B4==0) 
114B:  BCF    03.5
114C:  BTFSC  06.4
114D:  GOTO   15B
....................     if(checkcall()) 
114E:  BCF    0A.4
114F:  BSF    0A.3
1150:  GOTO   6A0
1151:  BSF    0A.4
1152:  BCF    0A.3
1153:  MOVF   78,F
1154:  BTFSC  03.2
1155:  GOTO   15B
....................     turndevice(); 
1156:  BCF    0A.4
1157:  BSF    0A.3
1158:  GOTO   78E
1159:  BSF    0A.4
115A:  BCF    0A.3
....................     } 
....................    } 
115B:  BSF    03.5
115C:  GOTO   09B
.................... } 
....................  
115D:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40

ROM data:
002100: 0031 0030 0030 0030 0030 

002110: 0030 0031 0036 0036 0033 0039 0031 0035 
002118: 0033 0030 0038 0020 0020 0020 0020 0020 

002160: 0031 0031 0031 0031 0031 0031 
